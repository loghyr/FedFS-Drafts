<?xml version="1.0" encoding="UTF-8"?>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="std" docName="draft-ietf-nfsv4-federated-fs-protocol-VERSIONVAR" ipr="pre5378Trust200902">

<front>

    <title>
    NSDB Protocol for Federated Filesystems
    </title>

    <?rfc include="author-lentini-james.xml"?>
    <?rfc include="author-everhart-craig.xml"?>
    <?rfc include="author-ellard-daniel.xml"?>
    <?rfc include="author-tewari-renu.xml"?>
    <?rfc include="author-naik-manoj.xml"?>

    <date/>

    <area> Internet </area>
    <workgroup> NFSv4 Working Group </workgroup>
    <keyword> Federated File Systems </keyword>

    <abstract>

    <t> This document describes a filesystem federation
    protocol that enables file access and namespace traversal
    across collections of independently administered
    fileservers.  The protocol specifies a set of interfaces by
    which fileservers with different administrators can form
    a fileserver federation that provides a namespace composed
    of the filesystems physically hosted on and exported by the
    constituent fileservers.  </t>

    </abstract>

    <note title="Requirements Language">

    <t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
        "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
        "MAY", and "OPTIONAL" in this document are to be
        interpreted as described in <xref target="RFC2119"/>.
    </t>

    </note>

</front>

<middle>

    <section title="Introduction">

    <t> A federated filesystem enables file access and namespace
    traversal in a uniform, secure and consistent manner across
    multiple independent fileservers within an enterprise or
    across multiple enterprises. </t>

    <t> This document specifies a set of protocols that allow
    fileservers, possibly from different vendors and with
    different administrators, to cooperatively form a federation
    containing one or more federated filesystems. Each federated
    filesystem's namespace is composed of the filesystems physically
    hosted on and exported by the federation's fileservers. A
    federation MAY contain a common namespace across all its
    fileservers. A federation MAY project multiple namespaces and
    enable clients to traverse each one. A federation MAY contain
    an arbitrary number of namespace repositories, each belonging
    to a different administrative entity, and each rendering a part
    of the namespace. A federation MAY also have an arbitrary number
    of administrative entities responsible for administering disjoint
    subsets of the fileservers. </t>

    <t> Traditionally, building a namespace that spans
    multiple fileservers has been difficult for two reasons.
    First, the fileservers that export pieces of the namespace
    are often not in the same administrative domain. Second, there
    is no standard mechanism for the fileservers to cooperatively
    present the namespace. Fileservers may provide proprietary
    management tools and in some cases an administrator may be
    able to use the proprietary tools to build a shared
    namespace out of the exported filesystems.  However, relying on
    vendor-specific proprietary tools does not work in larger enterprises
    or when collaborating across enterprises because the fileservers
    are likely to be from multiple vendors or use different software
    versions, each with their own namespace protocols, with no common
    mechanism to manage the namespace or exchange namespace information. </t>

    <t> The federated filesystem protocols in this document define
    how to construct a namespace accessible by an NFSv4 <xref target="3530bis"/>
    or NFSv4.1 <xref target="RFC5661"/> client and have been designed
    to accommodate other file access protocols in the future. </t>

    <t> The requirements for federated filesystems are described
    in <xref target="RFC5716"/>. A protocol for administering
    a fileserver's namespace is described in <xref target="FEDFS-ADMIN"/>.
    The mechanism for discovering the root of an NFSv4 namespace is
    described in <xref target="FEDFS-DNS-SRV"/>. </t>

    <t> In the rest of the document, the term fileserver denotes a
    fileserver that is part of a federation. </t>

    </section>

    <section title="Overview of Features and Concepts">

    <section title="File-access Protocol">

        <t> A file-access protocol is a network protocol for
        accessing data. The NFSv4 protocol and the NFSv4.1
        protocol are both examples of a file-access protocol. </t>

    </section>

    <section title="File-access Client">

        <t> File-access clients are standard off-the-shelf network
        attached storage (NAS) clients that communicate with
        fileservers using the NFSv4 protocol, the NFSv4.1 protocol,
        or some other file-access protocol. </t>

    </section>

    <section title="Fileserver">

        <t> Fileservers are servers that store the physical fileset
        data or refer the client to other fileservers. A fileserver
        can be implemented in a number of different ways, including
        a single system, a cluster of systems, or some other
        configuration. A fileserver provides access to a federated
        filesystem via NFSv4, NFSv4.1, or some other file-access
        protocol. </t>

    </section>

    <section title="Referral">

        <t> A referral is a mechanism by which a fileserver
        redirects a file-access protocol client to a different
        fileserver. The exact information contained in a referral
        varies from one file-access protocol to another. The NFSv4
        protocol defines the fs_locations attribute for
        referral information. The NFSv4.1 protocol defines the
        fs_locations_info attribute for referral information. </t>

    </section>

    <section title="Namespace">

        <t> The goal of a unified namespace is to make all
        managed data available to all clients via the same path
        in a common filesystem-like namespace.  This should be
        achieved with minimal or zero client configuration.  In
        particular, updates to the common namespace should not
        require configuration changes at the client.  Filesets,
        which are the unit of data management, are a set of
        files and directories.  From the perspective of the
        clients, the common namespace is constructed by mounting
        filesets that are physically located on different
        fileservers.  The namespace, which is defined in terms
        of fileset definitions, fileset identifiers, the
        location of each fileset in the namespace, and the
        physical location of the implementation(s) of each
        fileset, is stored in a set of namespace repositories,
        each managed by an administrative entity.  The namespace
        schema defines the model used for populating, modifying,
        and querying the namespace repositories.  It is not
        required by the federation that the namespace be common
        across all fileservers.  It should be possible to have
        several independently rooted namespaces. </t>

    </section>

    <section title="Fileset">

        <t> A fileset is defined to be a container of data and
        is the basic unit of data management.  Depending on the
        configuration, they may be anything between an individual
        directory of an exported filesystem to an entire exported
        filesystem at a fileserver. </t>

    </section>

    <section title="Fileset Name (FSN)">

        <t> A fileset is uniquely represented by its fileset name
        (FSN).  An FSN is considered unique across the federation.
        After an FSN is created, it is associated with one or more
        fileset locations (FSLs) on a fileserver. </t>

        <t> The attributes of an FSN are: </t>

<!--NOTE: hangIndent is set to 6 and hanging text has 3 space prefix to -->
<!--      set the list off from the body text.                          -->
        <t>
        <list style="hanging" hangIndent="6">

            <t hangText="   NsdbName:"> the network location of the
            NSDB node that contains authoritative information for
            this FSN. </t>

            <t hangText="   FsnUuid:"> a 128-bit UUID
            (universally unique identifier), conforming to
            <xref target="RFC4122"/>, that is used to uniquely
            identify an FSN. </t>

        </list>
        </t>

    </section>

    <section title="Fileset Location (FSL)">

        <t> An FSL describes the location where the fileset
        data resides.  An FSL contains generic and type specific
        information which together describe how to access the fileset.
        An FSL's type indicates which protocol(s) may be used
        to access its data. An FSL's attributes can be used by a fileserver
        to decide which locations it will return to a client. </t>

        <t> All FSLs have the following attributes: </t>

<!--NOTE: hangIndent is set to 6 and hanging text has 3 space prefix to -->
<!--      set the list off from the body text.                          -->
        <t>
        <list style="hanging" hangIndent="6">

            <t hangText="   FslUuid:"> a 128-bit UUID, conforming to
            <xref target="RFC4122"/>, that is used to uniquely
            identify an FSL. </t>

            <t hangText="   FsnUuid:"> the 128-bit UUID of the
            FSL's FSN. </t>

            <t hangText="   NsdbName:"> the network location of the
            NSDB node that contains authoritative information for
            this FSL. </t>

            <t hangText="   FslHost:"> the network location of the
            host fileserver storing the physical data </t>

            <t hangText="   FslTTL:"> the time in seconds during
            which the FSL may be cached </t>

            <t hangText="   Annotations:"> optional name/value pairs
            that can be interpreted by a fileserver. The semantics
            of this field are not defined by this document. These
            tuples are intended to be used by higher-level
            protocols. </t>

            <t hangText="   Descriptions:"> optional text
            descriptions. The semantics of this field are
            not defined by this document. </t>

        </list>
        </t>

        <t> This document defines an FSL subtype for NFS. An NFS FSL
        contains information suitable for use in an NFSv4
        fs_locations <xref target="3530bis"/> or NFSv4.1
        fs_locations_info attribute <xref target="RFC5661"/>. </t>

        <t> A fileset MAY be accessible by protocols other than NFS. For
        each such protocol, a corresponding FSL subtype SHOULD be defined.
        The contents and format of such FSL subtypes are not defined in
        this document. </t>

        <section title="Mutual Consistency across Fileset Locations">

        <t> All of the FSLs that have the same FSN (and thereby
        reference the same fileset) are equivalent from the
        point of view of client access; the different
        locations of a fileset represent the same data,
        though potentially at different points in time.
        Fileset locations are equivalent but not identical.
        Locations may either be read-only or read-write.
        Typically, multiple read-write locations are backed
        by a clustered filesystem while read-only locations
        are replicas created by a federation-initiated or
        external replication operation.  Read-only locations may
        represent consistent point-in-time copies of a
        read-write location.  The federation protocols,
        however, cannot prevent subsequent changes to a
        read-only location nor guarantee point-in-time
        consistency of a read-only location if the
        read-write location is changing.  </t>

        <t> Regardless of the type, all locations exist at
        the same mount point in the namespace and, thus, one
        client may be referred to one location while another
        is directed to a different location.  Since updates
        to each fileset location are not controlled by the
        federation protocol, it is the responsibility of
        administrators to guarantee the functional
        equivalence of the data.  </t>

        <t> The federation protocol does not guarantee that
        the different locations are mutually consistent in
        terms of the currency of the data.  It relies on the
        client file-access protocol to contain
        sufficient information to help the clients determine
        the currency of the data at each location in order
        to ensure that the clients do not revert back in
        time when switching locations. NFSv4.1 provides
    guidance on how replication can be handled in such a
    manner, in particular see Section 11.7 of
    <xref target='RFC5661' />.   </t>

        </section>

        <section title="Caching of Fileset Locations" anchor="fsl_caching">

        <t> To resolve an FSN to a set of FSL records, the
        fileserver queries the appropriate NSDB for the FSL records.
        A fileserver MAY cache these FSL records for a limited period
        of time. The period of time, if any, during which FSL records
        MAY be cached is indicated by the FSL's TTL field. </t>

        <t> The combination of FSL caching and FSL migration presents
        a challenge. For example, suppose there are three fileservers
        named A, B, and C and fileserver A contains a junction to
        fileset X stored on fileserver B. Now suppose that fileset X is
        migrated from fileserver B to fileserver C and the corresponding
        FSL information for fileset X in the appropriate NSDB is updated.
        If fileserver A has a cached FSL for fileset X, a user traversing
        the junction on fileserver A will be referred to fileserver B
        even though fileset X has migrated to fileserver C. If fileserver
        A had not cached  the FSL record, it would have queried the NSDB
        and obtained the correct location of fileset X. </t>

        <t> Administrators are advised to be aware of FSL caching when
        performing a migration. When migrating a fileset, administrators
        SHOULD create a junction at the fileset's old location referring
        back to the NSDB entry for the fileset. This junction will redirect
        any users who follow stale FSL information to the correct location.
        Thus, in the above example, fileserver A would direct clients
        to fileserver B, but fileserver B would in turn direct clients to
        fileserver C. </t>

        <t> Such supplemental junctions (on fileserver B in the example)
        would not be required to be in place forever. They need to stay
        in place only until cached FSL entries for the target fileset
        are invalidated. Each FSL contains a TTL field, a count in
        seconds of the time interval the FSL MAY be cached. This is an upper
        bound for the lifetime of the cached information and a lower bound for the
        lifetime of the supplemental junctions. For example, suppose this
        field contains the value 3600 seconds (one hour). In such a case,
        administrators MUST keep the supplemental junctions in place for at
        least one hour after the fileset move has taken place, and FSL data
        MUST NOT be cached by a referring fileserver for more than one hour
        without a refresh. </t>

        </section>

        <section title="Generating A Referral from Fileset Locations" anchor="fsl_referral">

        <t> After resolving an FSN to a set of FSL records, the
        fileserver can generate a referral to redirect the
        client to one or more of the FSLs. The fileserver will
        convert the FSL records to a referral format understood
        by the client, such as an NFSv4 fs_locations attribute
        or NFSv4.1 fs_locations_info attribute. </t>

        <t> In order to give the client as many options as
        possible, the fileserver SHOULD include the maximum
        possible number of FSL records in a referral. However,
        the fileserver MAY omit some of the FSL records
        from the referral. For example, the fileserver might
        omit an FSL record because of limitations in the file
        access protocol's referral format.  </t>

        <t> For a given FSL record, the fileserver MAY
        convert or reduce the FSL record's contents in a manner
        appropriate to the referral format. For example,
        an NFS FSL record contains all the data necessary to
        construct an NFSv4.1 fs_locations_info attribute,
        but an NFSv4.1 fs_locations_info attribute contains
        several pieces of information that are not found
        in an NFSv4 fs_locations attribute. A fileserver
        will construct entries in an NFSv4 fs_locations
        attribute using the relevant contents of an NFS FSL
        record.  </t>

        <t> Whenever the fileserver converts or reduces
        FSL data, the fileserver SHOULD attempt to maintain
        the original meaning where possible. For example, an
        NFS FSL record contains the rank and order information
        that is included in an NFSv4.1 fs_locations_info attribute
        (see NFSv4.1's FSLI4BX_READRANK, FSLI4BX_READORDER,
        FSLI4BX_WRITERANK, and FSLI4BX_WRITEORDER). While
        this rank and order information is not explicitly
        expressible in an NFSv4 fs_locations attribute, the
        fileserver can arrange the NFSv4 fs_locations
        attribute's locations list based on the rank and order
        values.  </t>

        <t> Refer to the NFSv4.1 protocol specification
        <xref target="RFC5661"/>, sections 11.9 and 11.10,
        for further details.  </t>

        </section>

    </section>

    <section title="Namespace Database (NSDB)">

        <t> The NSDB service is a federation-wide service that
        provides interfaces to define, update, and query FSN
        information, FSL information, and FSN to FSL mapping
        information.  </t>

        <t> An individual repository of namespace information
        is called an NSDB node.  The difference between the NSDB
        service and an NSDB node is analogous to that between the
        DNS service and a particular DNS server.  </t>

        <t> Each NSDB node is managed by a single administrative
        entity.  A single admininistrative entity can manage
        multiple NSDB nodes.  </t>

        <t> Each NSDB node stores the definition of the FSNs
        for which it is authoritative.  It also stores the
        definitions of the FSLs associated with those FSNs.  An
        NSDB node is authoritative for the filesets that it
        defines.  </t>

        <t> Each NSDB node supports an LDAP <xref target="RFC4510"/>
        interface.  The information stored on an NSDB node is
        accessed and updated by LDAP clients.  </t>

        <t> An NSDB MAY be replicated throughout the federation.
        If an NSDB is replicated, the NSDB MUST exhibit loose,
        converging consistency as defined in <xref target="RFC3254"/>.
        The mechanism by which this is achieved is outside the
        scope of this document. Many LDAP implementations support
        replication.  These features MAY be used to replicate
        the NSDB. </t>

    </section>

    <section title="Mount Points, Junctions and Referrals">

        <t> A mount point is a directory in a parent fileset
        where a target fileset may be attached.  If a client
        traverses the path leading from the root of the
        namespace to the mount point of a target fileset it
        should be able to access the data in that target
        fileset (assuming appropriate permissions).  </t>

        <t> The directory where a fileset is mounted is
        represented by a junction in the underlying filesystem.
        In other words, a junction can be viewed as a reference
        from a directory in one fileset to the root of the
        target fileset.  A junction can be implemented as a
        special marker on a directory that is interpreted by the
        fileserver as a mount point, or by some other mechanism
        in the underlying filesystem.  </t>

        <t> What data is used by the underlying filesystem to
        represent the junction is not defined by this protocol.
        The essential property is that the server must be able
        to find, given the junction, the FSN for the target
        fileset.  The mechanism by which the server maps a junction
        to an FSN is outside the scope of this document. The FSN
        (as described earlier) contains the authoritative
        NSDB node, and the FsnUuid (a UUID for the fileset).  </t>

        <t> When a client traversal reaches a junction, the
        client is referred to a list of FSLs associated with the
        FSN targeted by the junction.  The client can then redirect
        its connection to one of the FSLs.  This act is called a
        referral.  For NFSv4 and NFSv4.1 clients, the FSL information
        is returned in the fs_locations and fs_locations_info
        attributes respectively.  </t>

        <t> The federation protocols do not limit where and
        how many times a fileset is mounted in the namespace.
        Filesets can be nested; a fileset can be mounted under
        another fileset.  </t>

    </section>

    <section title="Unified Namespace and the Root Fileset">

        <t> The root fileset, when defined, is the top-level fileset
        of the federation-wide namespace. The root of the unified
        namespace is the top level directory of this fileset. A set of
        designated fileservers in the federation can export the root
        fileset to render the federation-wide unified namespace. When
        a client mounts the root fileset from any of these designated
        fileservers it can view a common federation-wide namespace.
        The root fileset could be implemented either as an exported
        NFS file system or as data in the NSDB itself. The properties
        and schema definition of an NSDB-based root fileset and
        the protocol details that describe how to configure and replicate
        the root fileset are not defined in this document.  </t>

    </section>

    <section anchor="sec:uuid" title="UUID Considerations">

        <t> To ensure FSN and FSL records are unique across a domain,
        FedFS employs UUIDs conforming to <xref target="RFC4122"/> to
        form the distinguished names of LDAP records containing FedFS
        data (see <xref target="fedfsfsn"/>).  </t>

        <t> Because junctions store a tuple containing an FSN UUID and
        the name and port of an NSDB service, an FSN UUID must be unique
        only on a single NSDB service.  The probability of two FSN
        records sharing the same UUID on a single NSDB host is zero,
        due to the way FSN distinguished names are formed.  An FSN
        UUID collision can be detected immediately when an
        administrator attempts to publish an FSN or FSL by storing
        it on an appropriate NSDB host.  </t>

        <t> Because FSLs are children of FSNs, FSL UUIDs must be unique
        for just a single FSN.  As with FSNs, as soon as an FSL is
        published, its uniqueness is guaranteed.  </t>

        <t> Of course, there is no way to guard against UUID re-use,
        but that is highly unlikely provided that UUIDs are constructed
        carefully.  </t>

        <t> A fileserver performs the operations described in
        <xref target="nsdb-ops-fileservers"/> as an unauthenticated user.
        Thus distinguished names of FSN and FSL records, as well as
        the FSN and FSL records themselves, are required to be readable
        by anyone who can bind anonymously to an NSDB service.  Therefore
        FSN and FSL UUIDs should be considered public information.  </t>

        <t> Version 1 UUIDs contain a host's MAC address and a time stamp
        in the clear.  This gives provenance to each UUID, but attackers
        can use such details to guess information about the host where the
        UUID was generated.  Security-sensitive installations should be
        aware that on externally-facing NSDBs, UUIDs can reveal
        information about the hosts where they are generated.  </t>

        <t> In addition, version 1 UUIDs depend on the notion that a
        hardware MAC address is unique across machines.  As virtual
      machines do not depend on unique physical MAC addresses and
      in any event an administrator can modify the physical MAC
      address, version 1 UUIDs are no longer considered sufficient.  </t>

        <t> To minimize the probability of UUIDs colliding, a
        consistent procedure for generating UUIDs should be used
        throughout a federation.  Within a federation, UUIDs SHOULD be
        generated using the procedure described for version 4 of the
        UUID variant specified in <xref target="RFC4122"/>.  </t>

    </section>

    </section>

    <section title="Examples">

    <t> In this section we provide examples and discussion of
    the basic operations facilitated by the federated
    filesystem protocol:  creating a fileset, adding a replica of a
    fileset, resolving a junction, and creating a junction. </t>

    <section title="Creating a Fileset and its FSL(s)">

        <t> A fileset is the abstraction of a set of files and
        the directory tree that contains them.  The fileset
        abstraction is the fundamental unit of data management
        in the federation.  This abstraction is implemented by
        an actual directory tree whose root location is
        specified by a fileset location (FSL).  </t>

        <t> In this section, we describe the basic requirements
        for starting with a directory tree and creating a
        fileset that can be used in the federation protocols.
        Note that we do not assume that the process of creating
        a fileset requires any transformation of the files or
        the directory hierarchy.  The only thing that is
        required by this process is assigning the fileset a
        fileset name (FSN) and expressing the location of the
        implementation of the fileset as an FSL.  </t>

        <t> There are many possible variations to this
        procedure, depending on how the FSN that binds the FSL
        is created, and whether other replicas of the fileset
        exist, are known to the federation, and need to be bound
        to the same FSN.  </t>

        <t> It is easiest to describe this in terms of how to
        create the initial implementation of the fileset, and
        then describe how to add replicas.  </t>

        <section title="Creating a Fileset and an FSN">

        <t>
            <list style="numbers">

            <t> Choose the NSDB node that will keep
                track of the FSL(s) and related
                information for the fileset. </t>

                <t> Create an FSN in the NSDB node.

                <vspace blankLines="1" />

                The FSN UUID is chosen by the administrator
                or generated automatically by administration software.
                The former case is used if the fileset is being
                restored, perhaps as part of disaster
                recovery, and the administrator wishes to
                specify the FSN UUID in order to permit
                existing junctions that reference that
                FSN to work again.

                <vspace blankLines="1" />

                At this point, the FSN exists, but its
                fileset locations are unspecified. </t>

            <t> For the FSN created above, create an
                FSL with the appropriate information in
                the NSDB node. </t>

            </list>
        </t>

        </section>

        <section title="Adding a Replica of a Fileset">

        <t> Adding a replica is straightforward:  the NSDB
        node and the FSN are already known.  The only
        remaining step is to add another FSL. </t>

        <t> Note that the federation protocols only provide
        the mechanisms to register and unregister replicas
        of a fileset. Fileserver-to-fileserver replication
        protocols are not defined. </t>

        </section>

    </section>

    <section title="Junction Resolution">

        <t> A fileset may contain references to other filesets.
        These references are represented by junctions.  If a
        client requests access to a fileset object that is a
        junction, the fileserver resolves the junction to discover
        one or more FSLs that implement the referenced fileset. </t>

        <t> There are many possible variations to this
        procedure, depending on how the junctions are
        represented by the fileserver and how the fileserver
        performs junction resolution. </t>

        <t> Step 4 is the only step that interacts directly with
        the federation protocols.  The rest of the steps may
        use platform-specific interfaces. </t>

        <t>
        <list style="numbers">

            <t> The fileserver determines that the object being
            accessed is a junction.  </t>

            <t> The fileserver does a local lookup to find the
            FSN of the target fileset.  </t>

            <t> Using the FSN, the fileserver finds the NSDB
            node responsible for the target FSN.  </t>

            <t> The fileserver contacts that NSDB node and
            asks for the set of FSLs that implement the target
            FSN.  The NSDB node responds with a (possibly
            empty) set of FSLs.  </t>

            <t> The fileserver converts one or more of the FSLs to
            the location type used by the client (e.g.,
            a Network File System (NFSv4) fs_location,
            as described in <xref target="3530bis"/>).  </t>

            <t> The fileserver redirects (in whatever manner is
            appropriate for the client) the client to the
            location(s).  </t>

        </list>
        </t>

    </section>

    <section title="Example Use Cases for Fileset Annotations">

        <t> Fileset annotations MAY be used to convey additional
        attributes of a fileset </t>

        <t> For example, fileset annotations can be used to define
        relationships between filesets that can be used by an
        auxiliary replication protocol.  Consider the scenario
        where a fileset is created and mounted at some point in
        the namespace.  A snapshot of the read-write FSL of that
        fileset is taken periodically at different frequencies
        say a daily snapshot or a weekly snapshot.  The
        different snapshots are mounted at different locations
        in the namespace.  The daily snapshots are considered as
        a different fileset from the weekly ones but both are
        related to the source fileset.  For this we can define
        an annotation labeling the filesets as source and
        replica.  The replication protocol can use this
        information to copy data from one or more FSLs of the
        source fileset to all the FSLs of the replica fileset.
        The replica filesets are read-only while the source
        fileset is read-write. </t>

        <t> This follows the traditional Andrew File System (AFS)
        model of mounting the read-only volume at a path in the
        namespace different from that of the read-write volume
        <xref target="AFS"/>. </t>

        <t> The federation protocol does not control or manage
        the relationship among filesets.  It merely enables
        annotating the filesets with user-defined relationships.
        </t>

        <t>  Another potential use for annotations is recording
        references to an FSN. A single annotation containing
        the number of references could be defined or multiple
        annotations, one per reference, could be used to store
        detailed information on the location of each reference.
        As with the replication annotation described above, the
        maintenance of reference information would not be controlled
        by the federation protocol. The information would mostly
        likely be non-authoritative because the ability to
        create a junction does not require the authority to
        update the FSN record. In any event, such annotations
        could be useful to administrators for determining if an
        FSN is referenced by a junction. </t>

    </section>
    </section>

    <section title="NSDB Configuration and Schema">

    <t> This section describes how an NSDB is constructed using
    an LDAP Version 3 <xref target="RFC4510"/> Directory.
    <xref target="ldap-config"/> describes the basic properties of
    the LDAP configuration that MUST be used in order to ensure
    compatibility between different implementations.
    <xref target="ldap-schema"/> defines the new LDAP
    attribute types, the new object types, and specifies how the
    distinguished name (DN) of each object instance MUST be
    constructed.  </t>

    <section title="LDAP Configuration" anchor="ldap-config">

        <t> An NSDB is constructed using an LDAP Directory.
        This LDAP Directory MAY have multiple naming contexts.
        For each naming context, the LDAP Directory's root DSE
        will have a namingContext attribute. Each namingContext
        attribute contains the DN of the naming context's root
        entry. For each naming context that contains federation
        entries (e.g., FSNs and FSLs): </t>

        <t>
        <list style="numbers">

        <t> There MUST be an LDAP entry that is superior
            to all of the naming context's federation entries in
            the Directory Information Tree (DIT) This entry is
            termed the NSDB Container Entry (NCE). The NCE's
            children are FSNs. An FSNs children are FSLs.
            </t>

        <t> The naming context's root entry MUST include
            the fedfsNsdbContainerInfo (defined below)
            as one of its object classes. The
            fedfsNsdbContainerInfo's fedfsNceDN
            attribute is used to locate the naming context's
            NCE.
        </t>

        </list>
        </t>

        <t> If a naming context does not contain federation entries,
        it will not contain an NCE and its root entry will not include
        a fedfsNsdbContainerInfo as one of its object classes. </t>

        <t> A fedfsNsdbContainerInfo's fedfsNceDN attribute
        contains the Distinguished Name (DN) of the NSDB Container
        Entry residing under this naming context. The fedfsNceDN
        attribute MUST NOT be empty. </t>

        <t> For example, an LDAP directory might have the following
        entries: </t>

        <figure><artwork><![CDATA[
        -+ [root DSE]
         |  namingContext: o=fedfs
         |  namingContext: dc=example,dc=com
         |  namingContext: ou=system
         |
         |
         +---- [o=fedfs]
         |      fedfsNceDN: o=fedfs
         |
         |
         +---- [dc=example,dc=com]
         |      fedfsNceDN: ou=fedfs,ou=corp-it,dc=example,dc=com
         |
         |
         +---- [ou=system]
        ]]></artwork></figure>

        <t> In this case, the o=fedfs namingContext has an NSBD
        Container Entry at o=fedfs, the dc=example,dc=com namingContext
        has an NSDB Container Entry at ou=fedfs,ou=corp-it,dc=example,dc=com,
        and the ou=system namingContext has no NSDB Container Entry. </t>

        <t> The NSDB SHOULD be configured with one or more privileged
        LDAP users. These users are able to modify the contents of the
        LDAP database. An administrator that performs the operations
        described in <xref target="nsdb-ops-admins"/> SHOULD authenticate
        using the DN of a privileged LDAP user. </t>

        <t> It MUST be possible for an unprivileged (unauthenticated)
        user to perform LDAP queries that access the NSDB data. A
        fileserver performs the operations described in
        <xref target="nsdb-ops-fileservers"/> as an unprivileged user. </t>

        <t> All implementations SHOULD use the same schema, or, at
        minimum, a schema that includes all of the objects, with each
        of the attributes, named in the following sections. </t>

        <t> Given the above configuration guidelines, an NSDB SHOULD be
        constructed using a dedicated LDAP directory. Separate LDAP
        directories are RECOMMENDED for other purposes, such as storing
        user account information. By using an LDAP directory dedicated
        to storing NSDB records, there is no need to disturb the
        configuration of any other LDAP directories that store
        information unrelated to an NSDB. </t>

    </section>

    <section title="LDAP Schema" anchor="ldap-schema">

        <t> The schema definitions provided in this document use the LDAP schema
        syntax defined in <xref target="RFC4512"/>. The definitions are
        formatted to allow the reader to easily extract them from the document.
        The reader can use the following shell script to extract the definitions: </t>

        <figure><artwork><![CDATA[

        <CODE BEGINS>

        #!/bin/sh
        grep '^ *///' | sed 's?^ */// ??' | sed 's?^ *///$??'

        <CODE ENDS>

        ]]></artwork></figure>

        <t> If the above script is stored in a file called "extract.sh", and
        this document is in a file called "spec.txt", then the reader can do: </t>

        <figure><artwork><![CDATA[

        <CODE BEGINS>

        sh extract.sh < spec.txt > fedfs.schema

        <CODE ENDS>

        ]]></artwork></figure>

        <t> The effect of the script is to remove leading white space from each
            line, plus a sentinel sequence of "///". </t>

        <t> As stated above, code components extracted from this
            document must include the following license: </t>

            <t> &lt;CODE BEGINS> </t>

    <t><cref>
    RFC Editor: please replace [draft-ietf-nfsv4-federated-fs-protocol-xx.txt]
    with this specification's RFC number.
    </cref></t>

            <figure><artwork><![CDATA[

  /// #
  /// # Copyright (c) 2010-2012 IETF Trust and the persons identified
  /// # as authors of the code.  All rights reserved.
  /// #
  /// # The authors of the code are the authors of
  /// # [draft-ietf-nfsv4-federated-fs-protocol-xx.txt]: J. Lentini,
  /// # C. Everhart, D. Ellard, R. Tewari, and M. Naik.
  /// #
  /// # Redistribution and use in source and binary forms, with
  /// # or without modification, are permitted provided that the
  /// # following conditions are met:
  /// #
  /// # - Redistributions of source code must retain the above
  /// #   copyright notice, this list of conditions and the
  /// #   following disclaimer.
  /// #
  /// # - Redistributions in binary form must reproduce the above
  /// #   copyright notice, this list of conditions and the
  /// #   following disclaimer in the documentation and/or other
  /// #   materials provided with the distribution.
  /// #
  /// # - Neither the name of Internet Society, IETF or IETF
  /// #   Trust, nor the names of specific contributors, may be
  /// #   used to endorse or promote products derived from this
  /// #   software without specific prior written permission.
  /// #
  /// #   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
  /// #   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
  /// #   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  /// #   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  /// #   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
  /// #   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  /// #   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  /// #   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  /// #   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  /// #   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  /// #   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  /// #   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  /// #   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
  /// #   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  /// #   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  /// #

            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        <section title="LDAP Attributes">

        <t> This section describes the required attributes of the NSDB
        LDAP schema. The following definitions are used below: </t>

        <t>
            <list style="symbols">

            <t> The "name" attribute described in <xref target="RFC4519"/>.  </t>

            <t> The Integer syntax (1.3.6.1.4.1.1466.115.121.1.27) described in <xref target="RFC4517"/>.  </t>

            <t> The "integerMatch" rule described in <xref target="RFC4517"/>.  </t>

            <t> The Octet String syntax (1.3.6.1.4.1.1466.115.121.1.40) described in <xref target="RFC4517"/>.  </t>

            <t> The "octetStringMatch" rule described in <xref target="RFC4517"/>.  </t>

            <t> The Boolean syntax (1.3.6.1.4.1.1466.115.121.1.7) described in <xref target="RFC4517"/>.  </t>

            <t> The "booleanMatch" rule described in <xref target="RFC4517"/>.  </t>

            <t> The "distinguishedNameMatch" rule described in <xref target="RFC4517"/>.  </t>

            <t> The DN syntax (1.3.6.1.4.1.1466.115.121.1.12) described in <xref target="RFC4517"/>.  </t>

            </list>
        </t>

        <section title="fedfsNetAddr">

            <t> A fedfsNetAddr is the locative name of a
            network service in either IPv4, IPv6, or DNS name
            notation. It MUST be a UTF-8 string and SHOULD be
            prepared using the server4 rules defined in Chapter 12
            "Internationalization" of <xref target="3530bis"/>. </t>

            <t> An IPv4 address MUST be represented using the standard
            dotted decimal format defined by the IPv4address rule in
            Section 3.2.2 of RFC 3986 <xref target="RFC3986"/>. An IPv6
            address MUST be represented using the format defined in
            Section 2.2 of RFC 4291 <xref target="RFC4291"/>. </t>

            <t> A DNS name MUST be represented using a fully qualified
            domain name. A system (i.e., fileserver or administrative host)
            SHOULD resolve the fully qualified domain name to a network
            address using the system's standard resolution mechanisms. </t>

            <t> This attribute is single-valued. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.2 NAME 'fedfsNetAddr'
        ///     DESC 'The network name of a host or service'
        ///     SUP name
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsNetPort">

            <t> A fedfsNetPort is the decimal representation of a
            transport service's port number. A fedfsNetPort MUST be
            encoded as an Integer syntax value
            <xref target="RFC4517"/>. </t>

            <t> This attribute is single-valued. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.3 NAME 'fedfsNetPort'
        ///     DESC 'A transport port number of a service'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFsnUuid">

            <t> A fedfsFsnUuid represents the UUID component of an FSN.
            An NSDB SHOULD ensure that no two FSNs it stores have the same
            fedfsFsnUuid. </t>

            <t> The fedfsFsnUuid is a subclass of UUID
            <xref target="RFC4530"/>, with the same encoding rules. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.4 NAME 'fedfsFsnUuid'
        ///     DESC 'The FSN UUID component of an FSN'
        ///     SUP UUID
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsNceDN">

            <t> A fedfsNceDN stores a distinguished name (DN). </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.7 NAME 'fedfsNceDN'
        ///     DESC 'NCE Distinguished Name'
        ///     EQUALITY distinguishedNameMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.12
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.12 is the DN
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsFslUuid">

            <t> A fedfsFslUuid represents the UUID of an FSL.
            An NSDB SHOULD ensure that no two FSLs it stores have the same
            fedfsFslUuid. </t>

            <t> The fedfsFslUuid is a subclass of UUID
            <xref target="RFC4530"/>, with the same encoding rules. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.8 NAME 'fedfsFslUuid'
        ///     DESC 'UUID of an FSL'
        ///     SUP UUID
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFslHost">

            <t> A fedfsFslHost is the host component of an FSL. The
            fedfsFslHost attribute is a subclass of fedfsNetAddr,
            with the same encoding rules. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.9 NAME 'fedfsFslHost'
        ///     DESC 'Service location for a fileserver'
        ///     SUP fedfsNetAddr
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFslPort">

            <t> A fedfsFslPort is the decimal representation of
            a file service's port number. The fedfsFslPort
            attribute is a subclass of fedfsNetPort, with the
            same encoding rules. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.10 NAME 'fedfsFslPort'
        ///     DESC 'The file service transport port number'
        ///     SUP fedfsNetPort
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFslTTL">

            <t> A fedfsFslTTL is the amount of time in seconds an FSL
            SHOULD be cached by a fileserver.  A fedfsFslTTL MUST
            be encoded as an Integer syntax value
            <xref target="RFC4517"/>.  </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.11 NAME 'fedfsFslTTL'
        ///     DESC 'Time to live of an FSL'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsAnnotation" anchor="fedfsAnnotation">

            <t> A fedfsAnnotation contains an object annotation
            formatted as a key/value pair. </t>

            <t> This attribute is multi-valued; an object type that
            permits annotations may have any number of annotations
            per instance. </t>

            <t> A fedfsAnnotation attribute is a human-readable
            sequence of UTF-8 characters with no non-terminal NUL
            characters. The value MUST be formatted according to
            the following ABNF <xref target="RFC5234"/> rules: </t>

<?rfc subcompact="yes" ?>
                <t><list style="empty">
            <t> ANNOTATION = KEY EQUALS VALUE </t>
            <t> KEY        = ITEM </t>
            <t> VALUE      = ITEM </t>
            <t> ITEM       = BLANK DQUOTE STR DQUOTE BLANK </t>
            <t> BLANK      = 0*EMPTY </t>
            <t> EMPTY      = SPACE / HTAB </t>
            <t> HTAB       = %x09 ; horizontal tab </t>
            <t> STR        = 0*UTF8 </t>
              </list></t>
<?rfc subcompact="no" ?>

           <t> The DQUOTE, EQUALS, UTF8, and SPACE rules are defined
           in <xref target="RFC4512"/>. </t>

           <t> The following escape sequences are allowed: </t>

            <texttable>
            <ttcol align='center'>escape sequence</ttcol>
            <ttcol align='center'>replacement</ttcol>
                <c>\\</c>
                <c>\ </c>
                <c>\"</c>
                <c>" </c>
            </texttable>

            <t> A fedfsAnnotation value SHOULD be processed as follows: </t>

                <t><list style="numbers">
            <t> Parse the attribute value according to the ANNOTATION rule,
                ignoring the escape sequences above. </t>
            <t> Scan through results of the previous step and replace the
                escape sequences above. </t>
                </list></t>

            <t> A fedfsAnnotation attribute that does not adhere to this format SHOULD
            be ignored. </t>

            <t> The following are examples of valid fedfsAnnotation attributes: </t>

            <figure><artwork><![CDATA[
         "key1" = "foo"
         "another key" = "x=3"
         "key-2" = "A string with \" and \\ characters."
            ]]></artwork></figure>

            <t> which correspond to the following key/value pairs: </t>

            <texttable>
            <ttcol align='center'>key</ttcol>
            <ttcol align='center'>value</ttcol>
                <c>key1</c>
                <c>foo</c>
                <c>another key</c>
                <c>x=3</c>
                <c>key-2</c>
                <c>A string with " and \ characters.</c>
            </texttable>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.12 NAME 'fedfsAnnotation'
        ///     DESC 'Annotation of an object'
        ///     SUP name
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsDescr">

            <t> A fedfsDescr stores an object description.
            The description MUST be encoded as a UTF-8 string.  </t>

            <t> This attribute is multi-valued which permits
            any number of descriptions per entry.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.13 NAME 'fedfsDescr'
        ///     DESC 'Description of an object'
        ///     SUP name
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsNfsPath">

            <t> A fedfsNfsPath is the path attribute of an FSL.
                The path MUST be the XDR encoded NFS path as
                defined by the NFS pathname4 XDR type of the
                fs_location's rootpath <xref target="3530bis"/>
                and the fs_locations_item's fli_rootpath
                <xref target="RFC5661"/>. The NFS pathname4 XDR
                type is a variable length array of component4
                elements. The NFS component4 XDR type is a variable
                length array of opaque data. A fedfsNfsPath
                attribute's component4 elements SHOULD be prepared
                using the component4 rules defined in Chapter 12
                "Internationalization" of
                <xref target="3530bis"/>. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.100 NAME 'fedfsNfsPath'
        ///     DESC 'Server-local path to a fileset'
        ///     EQUALITY octetStringMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.40
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.40 is the Octet String
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsCurrency">

            <t> A fedfsNfsCurrency stores the NFSv4.1 fs_locations_server's
            fls_currency value <xref target="RFC5661"/>. A fedfsNfsCurrency
            MUST be encoded as an Integer syntax value <xref target="RFC4517"/>
            in the range [-2147483648, 2147483647]. </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.103 NAME 'fedfsNfsCurrency'
        ///     DESC 'up-to-date measure of the data'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsGenFlagWritable">

            <t> A fedfsNfsGenFlagWritable stores the
            value of an FSL's NFSv4.1 FSLI4GF_WRITABLE bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is true. A value of
            "FALSE" indicates the bit is false. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.104 NAME 'fedfsNfsGenFlagWritable'
        ///     DESC 'Indicates if the filesystem is writable'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsGenFlagGoing">

            <t> A fedfsNfsGenFlagGoing stores the
            value of an FSL's NFSv4.1 FSLI4GF_GOING bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is true. A value of
            "FALSE" indicates the bit is false. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.105 NAME 'fedfsNfsGenFlagGoing'
        ///     DESC 'Indicates if the filesystem is going'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsGenFlagSplit">

            <t> A fedfsNfsGenFlagSplit stores the
            value of an FSL's NFSv4.1 FSLI4GF_SPLIT bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is true. A value of
            "FALSE" indicates the bit is false. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.106 NAME 'fedfsNfsGenFlagSplit'
        ///     DESC 'Indicates if there are multiple filesystems'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsTransFlagRdma">

            <t> A fedfsNfsTransFlagRdma stores the
            value of an FSL's NFSv4.1 FSLI4TF_RDMA bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is true. A value of
            "FALSE" indicates the bit is false. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.107 NAME 'fedfsNfsTransFlagRdma'
        ///     DESC 'Indicates if the transport supports RDMA'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassSimul">

            <t> A fedfsNfsClassSimul contains the FSL's NFSv4.1
            FSLI4BX_CLSIMUL <xref target="RFC5661"/> value. A
            fedfsNfsClassSimul MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.108 NAME 'fedfsNfsClassSimul'
        ///     DESC 'The simultaneous-use class of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassHandle">

            <t> A fedfsNfsClassHandle contains the FSL's NFSv4.1
            FSLI4BX_CLHANDLE <xref target="RFC5661"/> value. A
            fedfsNfsClassHandle MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.109 NAME 'fedfsNfsClassHandle'
        ///     DESC 'The handle class of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassFileid">

            <t> A fedfsNfsClassFileid contains the FSL's NFSv4.1
            FSLI4BX_CLFILEID <xref target="RFC5661"/> value. A
            fedfsNfsClassFileid MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.110 NAME 'fedfsNfsClassFileid'
        ///     DESC 'The fileid class of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassWritever">

            <t> A fedfsNfsClassWritever contains the FSL's NFSv4.1
            FSLI4BX_CLWRITEVER <xref target="RFC5661"/> value. A
            fedfsNfsClassWritever MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.111 NAME 'fedfsNfsClassWritever'
        ///     DESC 'The write-verifier class of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassChange">

            <t> A fedfsNfsClassChange contains the FSL's NFSv4.1
            FSLI4BX_CLCHANGE <xref target="RFC5661"/> value. A
            fedfsNfsClassChange MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.112 NAME 'fedfsNfsClassChange'
        ///     DESC 'The change class of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsClassReaddir">

            <t> A fedfsNfsClassReaddir contains the FSL's NFSv4.1
            FSLI4BX_CLREADDIR <xref target="RFC5661"/> value. A
            fedfsNfsClassReaddir MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.113 NAME 'fedfsNfsClassReaddir'
        ///     DESC 'The readdir class of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsReadRank">

            <t> A fedfsNfsReadRank contains the FSL's NFSv4.1
            FSLI4BX_READRANK <xref target="RFC5661"/> value. A
            fedfsNfsReadRank MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.114 NAME 'fedfsNfsReadRank'
        ///     DESC 'The read rank of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsReadOrder">

            <t> A fedfsNfsReadOrder contains the FSL's NFSv4.1
            FSLI4BX_READORDER <xref target="RFC5661"/> value. A
            fedfsNfsReadOrder MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.115 NAME 'fedfsNfsReadOrder'
        ///     DESC 'The read order of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsWriteRank">

            <t> A fedfsNfsWriteRank contains the FSL's
            FSLI4BX_WRITERANK <xref target="RFC5661"/> value. A
            fedfsNfsWriteRank MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>


            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.116 NAME 'fedfsNfsWriteRank'
        ///     DESC 'The write rank of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsWriteOrder">

            <t> A fedfsNfsWriteOrder contains the FSL's
            FSLI4BX_WRITEORDER <xref target="RFC5661"/> value. A
            fedfsNfsWriteOrder MUST be encoded as an Integer
            syntax value <xref target="RFC4517"/> in the
            range [0, 255]. </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.117 NAME 'fedfsNfsWriteOrder'
        ///     DESC 'The write order of the filesystem'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsVarSub">

            <t> A fedfsNfsVarSub stores the
            value of an FSL's NFSv4.1 FSLI4F_VAR_SUB bit
            <xref target="RFC5661"/>. A value of "TRUE"
            indicates the bit is true. A value of
            "FALSE" indicates the bit is false. </t>
            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.118 NAME 'fedfsNfsVarSub'
        ///     DESC 'Indicates if variable substitution is present'
        ///     EQUALITY booleanMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.7
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.7 is the Boolean
            syntax <xref target="RFC4517"/>.  </t>

        </section>

        <section title="fedfsNfsValidFor">

            <t> A fedfsNfsValidFor stores an FSL's NFSv4.1 fs_locations_info
            fli_valid_for value <xref target="RFC5661"/>. A fedfsNfsValidFor
            MUST be encoded as an Integer syntax value <xref target="RFC4517"/>
            in the range [-2147483648, 2147483647].  </t>

            <t> An FSL's fedfsFslTTL value and fedfsNfsValidFor value
            MAY be different.  </t>

            <t> This attribute is single-valued.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// attributetype (
        ///     1.3.6.1.4.1.31103.1.19 NAME 'fedfsNfsValidFor'
        ///     DESC 'Valid for time'
        ///     EQUALITY integerMatch
        ///     SYNTAX 1.3.6.1.4.1.1466.115.121.1.27
        ///     SINGLE-VALUE
        ///     )
        ///
            ]]></artwork></figure>

            <t> OID 1.3.6.1.4.1.1466.115.121.1.27 is the Integer
            syntax <xref target="RFC4517"/>.  </t>

            <t> &lt;CODE ENDS> </t>

        </section>

        </section> <!-- LDAP Attributes -->

        <section title="LDAP Objects">

        <section title="fedfsNsdbContainerInfo">

            <t> A fedfsNsdbContainerInfo describes the location of
            the NCE.  </t>

            <t> A fedfsFsn's fedfsNceDN attribute is REQUIRED.  </t>

            <t> A fedfsFsn's fedfsAnnotation and fedfsDescr attributes
            are OPTIONAL.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// objectclass (
        ///     1.3.6.1.4.1.31103.1.1001 NAME 'fedfsNsdbContainerInfo'
        ///     DESC 'Describes NCE location'
        ///     SUP top AUXILIARY
        ///     MUST (
        ///             fedfsNceDN
        ///     )
        ///     MAY (
        ///             fedfsAnnotation
        ///             $ fedfsDescr
        ///     ))
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFsn" anchor="fedfsfsn">

            <t> A fedfsFsn represents an FSN.  </t>

            <t> A fedfsFsn's fedfsFsnUuid attribute is REQUIRED.  </t>

            <t> A fedfsFsn's fedfsAnnotation and
            fedfsDescr attributes are OPTIONAL.  </t>

            <t> The DN of an FSN is REQUIRED to take the following
            form:  "fedfsFsnUuid=$FSNUUID,$NCE", where $FSNUUID
            is the UUID of the FSN and $NCE is the DN of the NCE
            ("o=fedfs" by default). Since LDAP requires a DN to be
            unique, this ensures that each FSN entry has a unique
            UUID value within the LDAP directory.  </t>

            <t> A fedfsFsn MAY also have additional attributes, but
            these attributes MUST NOT be referenced by any part of
            this document.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// objectclass (
        ///     1.3.6.1.4.1.31103.1.1002 NAME 'fedfsFsn'
        ///     DESC 'Represents a fileset'
        ///     SUP top STRUCTURAL
        ///     MUST (
        ///             fedfsFsnUuid
        ///     )
        ///     MAY (
        ///             $ fedfsAnnotation
        ///             $ fedfsDescr
        ///     ))
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsFsl" anchor="fedfsfsl">

            <t> The fedfsFsl object class represents an FSL.  </t>

            <t> The fedfsFsl is an abstract object class. Protocol
            specific subtypes of this object class are used to
            store FSL information. The fedfsNfsFsl object
            class defined below is used to record an NFS FSL's
            location.  Other subtypes MAY be defined for other
            protocols (e.g., CIFS).  </t>

            <t> A fedfsFsl's fedfsFslUuid, fedfsFsnUuid,
            fedfsFslHost, and fedfsFslTTL attributes are REQUIRED.  </t>

            <t> A fedfsFsl's fedfsFslPort, fedfsAnnotation, and
            fedfsDescr attributes are OPTIONAL.  </t>

            <t> If the fedfsFslPort is omitted, a standard port
            number based on the type of FSL should be assumed. For
            an NFS FSL, the standard NFS port number, 2049, SHOULD
            be assumed. </t>

            <t> The DN of an FSL is REQUIRED to take the following
            form:  "fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE"
            where $FSLUUID is the FSL's UUID, $FSNUUID is the FSN's
            UUID, and $NCE is the DN of the NCE ("o=fedfs" by default).
            Since LDAP requires a DN to be unique, this ensures that each
            FSL entry has a unique UUID value within the LDAP
            directory.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// objectclass (
        ///     1.3.6.1.4.1.31103.1.1003 NAME 'fedfsFsl'
        ///     DESC 'A physical location of a fileset'
        ///     SUP top ABSTRACT
        ///     MUST (
        ///             fedfsFslUuid
        ///             $ fedfsFsnUuid
        ///             $ fedfsFslHost
        ///             $ fedfsFslTTL
        ///     )
        ///     MAY (
        ///             $ fedfsFslPort
        ///             $ fedfsAnnotation
        ///             $ fedfsDescr
        ///     ))
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        <section title="fedfsNfsFsl">

            <t> A fedfsNfsFsl is used to represent an
            NFS FSL. The fedfsNfsFsl inherits all of the
            attributes of the fedfsFsl and extends the
            fedfsFsl with information specific to the
            NFS protocol. </t>

            <t> The DN of an NFS FSL is REQUIRED to take the following
            form:  "fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE"
            where $FSLUUID is the FSL's UUID, $FSNUUID is the FSN's
            UUID, and $NCE is the DN of the NCE ("o=fedfs" by default).
            Since LDAP requires a DN to be unique, this ensures that each
            NFS FSL entry has a unique UUID value within the LDAP
            directory.  </t>

            <t> &lt;CODE BEGINS> </t>

            <figure><artwork><![CDATA[
        ///
        /// objectclass (
        ///     1.3.6.1.4.1.31103.1.1004 NAME 'fedfsNfsFsl'
        ///     DESC 'An NFS location of a fileset'
        ///     SUP fedfsFsl STRUCTURAL
        ///     MUST (
        ///             fedfsNfsPath
        ///             $ fedfsNfsCurrency
        ///             $ fedfsNfsGenFlagWritable
        ///             $ fedfsNfsGenFlagGoing
        ///             $ fedfsNfsGenFlagSplit
        ///             $ fedfsNfsTransFlagRdma
        ///             $ fedfsNfsClassSimul
        ///             $ fedfsNfsClassHandle
        ///             $ fedfsNfsClassFileid
        ///             $ fedfsNfsClassWritever
        ///             $ fedfsNfsClassChange
        ///             $ fedfsNfsClassReaddir
        ///             $ fedfsNfsReadRank
        ///             $ fedfsNfsReadOrder
        ///             $ fedfsNfsWriteRank
        ///             $ fedfsNfsWriteOrder
        ///             $ fedfsNfsVarSub
        ///             $ fedfsNfsValidFor
        ///     ))
        ///
            ]]></artwork></figure>

            <t> &lt;CODE ENDS> </t>

        </section>

        </section> <!-- LDAP Objects -->

    </section> <!-- LDAP Schema -->

    </section> <!-- Mapping the NSDB onto LDAP -->

    <section title="NSDB Operations" anchor="nsdb-ops">

    <t> The operations defined by the protocol can be described
    as several sub-protocols that are used by entities within
    the federation to perform different roles.  </t>

    <t> The first of these sub-protocols defines how the state
    of an NSDB node can be initialized and updated.  The
    primary use of this sub-protocol is by an administrator to
    add, edit, or delete filesets, their properties, and their
    fileset locations.  </t>

    <t> The second of these sub-protocols defines the queries
    that are sent to an NSDB node in order to perform
    resolution (or to find other information about the data
    stored within that NSDB node) and the responses returned
    by the NSDB node.  The primary use of this sub-protocol
    is by a fileserver in order to perform resolution, but
    it may also be used by an administrator to query the state
    of the system.  </t>

    <t> The first and second sub-protocols are defined as LDAP
    operations, using the schema defined in the previous section.
    If each NSDB node is a standard LDAP server, then, in
    theory, it is unnecessary to describe the LDAP operations in
    detail, because the operations are ordinary LDAP operations
    to query and update records.  However, we do not require
    that an NSDB node implement a complete LDAP service, and
    therefore we define in these sections the minimum level of
    LDAP functionality required to implement an NSDB node. </t>

    <t> The NSDB sub-protocols are defined in the next two
    sub-sections. The descriptions of LDAP messages in these
    sections use the LDAP Data Interchange Format (LDIF)
    <xref target="RFC2849"/>. In order to differentiate constant
    and variable strings in the LDIF specifications, variables
    are prefixed by a $ character and use all upper case characters.
    For example, a variable named FOO would be specified as $FOO. </t>

    <t> This document uses the term NSDB client to refer to an LDAP
    client that uses either of the NSDB sub-protocols</t>

    <t> The third sub-protocol defines the queries and
    other requests that are sent to a fileserver in order to
    get information from it or to modify the state of the
    fileserver in a manner related to the federation
    protocols.  The primary purpose of this protocol is for
    an administrator to create or delete a junction or discover
    related information about a particular fileserver. </t>

    <t> The third sub-protocol is defined as an ONC RPC protocols.
    The reason for using ONC RPC instead of LDAP is that all
    fileservers support ONC RPC but some do not support an LDAP
    Directory server.  </t>

    <t> The ONC RPC administration protocol is defined in
    <xref target="FEDFS-ADMIN"/>. </t>

    <section title="NSDB Operations for Administrators" anchor="nsdb-ops-admins">

        <t> The admin entity initiates and controls the commands
        to manage fileset and namespace information.  The admin
        entity, however, is stateless.  All state is maintained
        at the NSDB nodes or at the fileserver.  </t>

        <t> We require that each NSDB node be able to act as
        an LDAP server and that the protocol used for
        communicating between the admin entity and each NSDB
        node is LDAP.  </t>

        <t> The names we assign to these operations are entirely
        for the purpose of exposition in this document, and are
        not part of the LDAP dialogs.  </t>

        <section title="Create an FSN">

        <t> This operation creates a new FSN in
        the NSDB by adding a new fedfsFsn entry in the
        NSDB's LDAP directory. </t>

        <t> A fedfsFsn entry contains a fedfsFsnUuid.
        The administrator chooses the fedfsFsnUuid by a
        process described in <xref target="sec:uuid"/>). </t>

        <t> The NSDB node that receives the request
        SHOULD check all of the attributes for validity and
        consistency, but this is not generally possible for
        LDAP servers because the consistency requirements
        cannot be expressed in the LDAP schema (although
        many LDAP servers can be extended, via plug-ins or
        other mechanisms, to add functionality beyond the
        strict definition of LDAP). </t>

        <section title="LDAP Request">

            <t> This operation is implemented using the LDAP ADD
            request described by the LDIF below. </t>

            <figure><artwork><![CDATA[
        dn: fedfsFsnUuid=$FSNUUID,$NCE
        changeType: add
        objectClass: fedfsFsn
        fedfsFsnUuid: $FSNUUID
            ]]></artwork></figure>

            <t> For example, if the $FSNUUID is
            "e8c4761c-eb3b-4307-86fc-f702da197966", and the
            $NCE is "o=fedfs" the operation would be: </t>

            <figure><artwork><![CDATA[
        dn: fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: add
        objectClass: fedfsFsn
        fedfsFsnUuid: e8c4761c-eb3b-4307-86fc-f702da197966
            ]]></artwork></figure>

        </section>

        </section>

        <section title="Delete an FSN">

        <t> This operation deletes an FSN by removing a
        fedfsFsn entry in the NSDB's LDAP directory. </t>

        <t> If the FSN entry being deleted has child FSL entries,
        this function MUST return an error.  This ensures that the
        NSDB will not contain any orphaned FSL entries. A compliant LDAP
        implementation will meet this requirement since Section 4.8
        of <xref target="RFC4511"/> defines the LDAP delete operation
        to only be capable of removing leaf entries.  </t>

        <t> Note that the FSN delete function only removes
        the fileset from the namespace (by removing the
        records for that FSN from the NSDB node that
        receives this request).  The fileset and its data
        are not deleted.  Any junction that has this FSN as
        its target may continue to point to this
        non-existent FSN.  A dangling reference may be
        detected when a client tries to resolve the target
        of a junction that refers to the deleted FSN and the
        NSDB returns an error.  </t>

        <section title="LDAP Request">

            <t> This operation is implemented using the LDAP
            DELETE request described by the LDIF below. </t>

            <figure><artwork><![CDATA[
        dn: fedfsFsnUuid=$FSNUUID,$NCE
        changeType: delete
            ]]></artwork></figure>

            <t> For example, if the $FSNUUID is
            "e8c4761c-eb3b-4307-86fc-f702da197966" and $NCE
            is "o=fedfs", the operation would be: </t>

            <figure><artwork><![CDATA[
    dn: fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: delete
            ]]></artwork></figure>

        </section>

        </section>

        <section title="Create an FSL">

        <t> This operation creates a new FSL for the
        given FSN by adding a new fedfsFsl entry in the
        NSDB's LDAP directory. </t>

        <t> A fedfsFsl entry contains a fedfsFslUuid,
        fedfsFsnUuid, fedfsFslHost, and fedfsFslTTL.  The
        administrator chooses the fedfsFslUuid.  The process
        for choosing the fedfsFslUuid is described in
        <xref target="sec:uuid"/>.  The fedfsFsnUuid is
        the UUID of the FSL's FSN.  The fedfsFslHost value is
        the network location of the fileserver that stores the
        FSL. The fedfsFslTTL is chosen by the administrator
        as described in <xref target="fsl_caching"/>. </t>

        <t> The administrator will also set additional
        attributes depending on the FSL type. </t>

        <section title="LDAP Request">

            <t> This operation is implemented using the LDAP
            ADD request described by the LDIF below (NOTE:
            the LDIF shows the creation of an NFS FSL)  </t>

<!--NOTE: the funny artwork formatting is needed to keep xml2rfc happy -->
<!--      If artwork lines are too long, version 1.34pre2 fails        -->
            <figure><artwork><![CDATA[

        dn:fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE
        changeType: add
        objectClass: fedfsNfsFsl
        fedfsFslUuid: $FSLUUID
        fedfsFsnUuid: $FSNUUID
        fedfsFslHost: $HOST
        fedfsFslPort: $PORT
        fedfsFslTTL: $TTL
        fedfsNfsPath: $PATH
        fedfsNfsCurrency: $CURRENCY
        fedfsNfsGenFlagWritable: $WRITABLE
        fedfsNfsGenFlagGoing: $GOING
        fedfsNfsGenFlagSplit: $SPLIT
        fedfsNfsTransFlagRdma: $RDMA
        fedfsNfsClassSimul: $CLASS_SIMUL
        fedfsNfsClassHandle:$CLASS_HANDLE
        fedfsNfsClassFileid:$CLASS_FILEID
        fedfsNfsClassWritever:$CLASS_WRITEVER
        fedfsNfsClassChange: $CLASS_CHANGE
        fedfsNfsClassReaddir: $CLASS_READDIR
        fedfsNfsReadRank: $READ_RANK
        fedfsNfsReadOrder: $READ_ORDER
        fedfsNfsWriteRank: $WRITE_RANK
        fedfsNfsWriteOrder: $WRITE_ORDER
        fedfsNfsVarSub: $VAR_SUB
        fedfsNfsValidFor: $TIME
        fedfsAnnotation: $ANNOTATION
        fedfsDescr: $DESCR

            ]]></artwork></figure>

            <t> For example, if the $FSNUUID is "e8c4761c-eb3b-4307-86fc-f702da197966",
            the $FSLUUID is "ba89a802-41a9-44cf-8447-dda367590eb3",
            the $HOST is "server.example.com", $PORT is "2049", the $TTL is "300" seconds,
            the $PATH is stored in the file "/tmp/fsl_path", $CURRENCY is "0" (an up to date
            copy), the FSL is writable, but not going, split, or accessible via RDMA,
            the simultaneous-use class is "1", the handle class is "0", the fileid class is
            "1", the write-verifier class is "1", the change class is "1", the readdir class is
            "9", the read rank is "7", the read order is "8", the write rank is "5", the
            write order is "6", variable substitution is false, $TIME is "300"
            seconds, $ANNOTATION is ""foo" = "bar"", $DESC is "This is a description.",
            and the $NCE is "o=fedfs", the operation would be (for readability the DN is
            split into two lines): </t>

            <figure><artwork><![CDATA[

        dn:fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,
            fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: add
        objectClass: fedfsNfsFsl
        fedfsFslUuid: ba89a802-41a9-44cf-8447-dda367590eb3
        fedfsFsnUuid: e8c4761c-eb3b-4307-86fc-f702da197966
        fedfsFslHost: server.example.com
        fedfsFslPort: 2049
        fedfsFslTTL: 300
        fedfsNfsPath:< file:///tmp/fsl_path
        fedfsNfsCurrency: 0
        fedfsNfsGenFlagWritable: TRUE
        fedfsNfsGenFlagGoing: FALSE
        fedfsNfsGenFlagSplit: FALSE
        fedfsNfsTransFlagRdma: FALSE
        fedfsNfsClassSimul: 1
        fedfsNfsClassHandle: 0
        fedfsNfsClassFileid: 1
        fedfsNfsClassWritever: 1
        fedfsNfsClassChange: 1
        fedfsNfsClassReaddir: 9
        fedfsNfsReadRank: 7
        fedfsNfsReadOrder: 8
        fedfsNfsWriteRank: 5
        fedfsNfsWriteOrder: 6
        fedfsNfsVarSub: FALSE
        fedfsNfsValidFor: 300
        fedfsAnnotation: "foo" = "bar"
        fedfsDescr: This is a description.

            ]]></artwork></figure>

        </section>

        <section title="Selecting fedfsNfsFsl Values">

            <t> The fedfsNfsFSl object class is used to describe NFSv4
            and NFSv4.1 accessible filesets. For the reasons described
            in <xref target="fsl_referral"/>, administrators SHOULD
            choose reasonable values for all LDAP attributes of an NFSv4
            accessible fedfsNfsFsl even though some of these LDAP
            attributes are not explicitly contained in the NFSv4
            fs_locations attribute returned to an NFSv4 client. </t>

            <t> When the administrator is unable to choose reasonable
            values for the LDAP attributes not explicitly contained
            in a NFSv4 fs_locations attribute, the values in the
            following table are RECOMMENDED. </t>

            <texttable>
            <ttcol align='left'>LDAP attribute</ttcol>
            <ttcol align='left'>LDAP value</ttcol>
            <ttcol align='left'>Notes</ttcol>
                <c>fedfsNfsCurrency</c>
                <c>negative value</c>
                <c>Indicates that the server does not know the currency (see 11.10.1 of <xref target="RFC5661"/>).</c>
                <c>fedfsNfsGenFlagWritable</c>
                <c>FALSE</c>
                <c>Leaving unset is not harmful (see 11.10.1 of <xref target="RFC5661"/>).</c>
                <c>fedfsNfsGenFlagGoing</c>
                <c>FALSE</c>
                <c>NFS client will detect a migration event if the FSL becomes unavailable.</c>
                <c>fedfsNfsGenFlagSplit</c>
                <c>TRUE</c>
                <c>Safe to assume that the FSL is split.</c>
                <c>fedfsNfsTransFlagRdma</c>
                <c>TRUE</c>
                <c>NFS client will detect if RDMA access is available.</c>
                <c>fedfsNfsClassSimul</c>
                <c>0</c>
                <c>0 is treated as non-matching (see 11.10.1 of <xref target="RFC5661"/>).</c>
                <c>fedfsNfsClassHandle</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsClassFileid</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsClassWritever</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsClassChange</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsClassReaddir</c>
                <c>0</c>
                <c>See fedfsNfsClassSimul note.</c>
                <c>fedfsNfsReadRank</c>
                <c>0</c>
                <c>Highest value ensures FSL will be tried.</c>
                <c>fedfsNfsReadOrder</c>
                <c>0</c>
                <c>See fedfsNfsReadRank note.</c>
                <c>fedfsNfsWriteRank</c>
                <c>0</c>
                <c>See fedfsNfsReadRank note.</c>
                <c>fedfsNfsWriteOrder</c>
                <c>0</c>
                <c>See fedfsNfsReadRank note.</c>
                <c>fedfsNfsVarSub</c>
                <c>FALSE</c>
                <c>NFSv4 does not define variable substituion in paths.</c>
                <c>fedfsNfsValidFor</c>
                <c>0</c>
                <c>Indicates no appropriate refetch interval (see 11.10.2 of <xref target="RFC5661"/>).</c>
            </texttable>

        </section>

        </section>

        <section title="Delete an FSL">

        <t> This operation deletes the given Fileset location.  The
        admin requests the NSDB node storing the fedfsFsl to
        delete it from its database.  This operation does
        not result in the fileset location's data being
        deleted at the fileserver.  </t>

        <section title="LDAP Request">

            <t> The admin sends an LDAP DELETE request to the NSDB node
            to remove the FSL. </t>

<!--NOTE: the funny artwork formatting is needed to keep xml2rfc happy -->
<!--      If artwork lines are too long, version 1.34pre2 fails        -->
            <figure><artwork><![CDATA[

        dn: fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE
        changeType: delete

            ]]></artwork></figure>

            <t> For example, if the $FSNUUID is "e8c4761c-eb3b-4307-86fc-f702da197966",
            the $FSLUUID is "ba89a802-41a9-44cf-8447-dda367590eb3", and the $NCE is
            "o=fedfs", the operation would be (for readability the DN is split into
            two lines): </t>

            <figure><artwork><![CDATA[

        dn: fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,
             fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: delete

            ]]></artwork></figure>

        </section>

        </section>

        <section title="Update an FSL">

        <t> This operation updates the attributes of a given FSL.
        This command results in a change in the attributes of the
        fedfsFsl at the NSDB node maintaining this FSL.
        The attributes that must not change are the fedfsFslUuid
        and the fedfsFsnUuid of the fileset this FSL implements.
        </t>

        <section title="LDAP Request">

            <t> The admin sends an LDAP MODIFY request to the NSDB node
            to update the FSL. </t>

<!--NOTE: the funny artwork formatting is needed to keep xml2rfc happy -->
<!--      If artwork lines are too long, version 1.34pre2 fails        -->
            <figure><artwork><![CDATA[

        dn: fedfsFslUuid=$FSLUUID,fedfsFsnUuid=$FSNUUID,$NCE
        changeType: modify
        replace: $ATTRIBUTE-TYPE

            ]]></artwork></figure>

            <t> For example, if the $FSNUUID is "e8c4761c-eb3b-4307-86fc-f702da197966",
            the $FSLUUID is "ba89a802-41a9-44cf-8447-dda367590eb3", the $NCE is "o=fedfs",
            and the administrator wished to change the TTL to 10 minutes, the operation
            would be (for readability the DN is split into two lines): </t>

            <figure><artwork><![CDATA[

        dn: fedfsFslUuid=ba89a802-41a9-44cf-8447-dda367590eb3,
             fedfsFsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
        changeType: modify
        replace: fedfsFslTTL
        fedfsFslTTL: 600

            ]]></artwork></figure>

        </section>

        </section>

    </section>

    <section title="NSDB Operations for Fileservers" anchor="nsdb-ops-fileservers">

        <section title="NSDB Container Entry (NCE) Enumeration">

        <t> To find the NCEs for the NSDB foo.example.com, a fileserver would do
        the following: </t>

            <figure><artwork><![CDATA[
        nce_list = empty
        connect to the LDAP directory at foo.example.com
        for each namingContext value $BAR in the root DSE
            /* $BAR is a DN */
            query for a fedfsNceDN value at $BAR
            /*
             * The LDAP URL for this search would be
             *
             *  ldap://foo.example.com:389/$BAR?fedfsNceDN??
             *                      (objectClass=fedfsNsdbContainerInfo)
             *
             */
            if a fedfsNceDN value is found
                add the value to the nce_list
            ]]></artwork></figure>

        </section>

        <section title="Lookup FSLs for an FSN">

        <t> Using an LDAP search, the fileserver can obtain
        all of the FSLs for a given FSN. The FSN's fedfsFsnUuid
        is used as the search key. The following examples use
        the LDAP Universal Resource Identifier (URI) format defined
        in <xref target="RFC4516"/>. </t>

        <t> To obtain a list of all FSLs for $FSNUUID on the NSDB
        named $NSDBNAME, the following search can be used
        (for readability the URI is split into two lines): </t>

        <figure><artwork><![CDATA[

        for each $NCE in nce_list
            ldap://$NSDBNAME/fsnUuid=$FSNUUID,$NCE??one?
                (objectClass=fedfsFsl)

        ]]></artwork></figure>

        <t> This search is for the children of the object with DN
        "fedfsFsnUuid=$FSNUUID,$NCE" with a filter for
        "objectClass=fedfsFsl". The scope value of "one" restricts
        the search to the entry's children (rather than the entire
        subtree below the entry) and the filter ensures that only
        FSL entries are returned. </t>

        <t> For example if $NSDBNAME is "nsdb.example.com", $FSNUUID
        is "e8c4761c-eb3b-4307-86fc-f702da197966", and $NCE is
        "o=fedfs", the search would be (for readability the URI is split
        into three lines): </t>

        <figure><artwork><![CDATA[

        ldap://nsdb.example.com/
                fsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
                ??one?(objectClass=fedfsFsl)

        ]]></artwork></figure>

        <t> The following search can be used to obtain
        only the NFS FSLs for $FSNUUID on the NSDB named
        $NSDBNAME (for readability the URI is split into two lines): </t>

        <figure><artwork><![CDATA[

        for each $NCE in nce_list
            ldap://$NSDBNAME/fsnUuid=$FSNUUID,$NCE??one?
                (objectClass=fedfsNfsFsl)

        ]]></artwork></figure>

        <t> This also searches for the children of the object with DN
        "fedfsFsnUuid=$FSNUUID,$NCE", but the filter for
        "objectClass = fedfsNfsFsl" restricts the results to only
        NFS FSLs. </t>

        <t> For example if $NSDBNAME is nsdb.example.com, $FSNUUID
        is "e8c4761c-eb3b-4307-86fc-f702da197966", and $NCE is
        "o=fedfs",the search would be (for readability the URI is split
        into three lines): </t>

        <figure><artwork><![CDATA[

        ldap://nsdb.example.com/
                fsnUuid=e8c4761c-eb3b-4307-86fc-f702da197966,o=fedfs
                ??one?(objectClass=fedfsNfsFsl)

        ]]></artwork></figure>

        <t> The fileserver will generate a referral based on the
        set of FSLs returned by these queries using the process
        described in <xref target="fsl_referral"/>. </t>

        </section>

    </section>

    <section title="NSDB Operations and LDAP Referrals">

        <t> The LDAPv3 protocol defines an LDAP referral mechanism
        that allows an LDAP server to redirect an LDAP client. LDAPv3
        defines two types of LDAP referrals: the Referral type defined
        in Section 4.1.10 of <xref target="RFC4511"/> and the
        SearchResultReference type defined in Section 4.5.3 of
        <xref target="RFC4511"/>. In both cases, the LDAP referral
        lists one or more URIs for services that can be used to
        complete the operation. In the remainder of this document,
        the term LDAP referral is used to indicate either of these
        types. </t>

        <t> If an NSDB operation results in an LDAP referral, the
        NSDB client MAY follow the LDAP referral. An NSDB client's
        decision to follow an LDAP referral is implementation and
        configuration dependent. For example, an NSDB client might
        be configured to follow only those LDAP referrals that were
        received over a secure channel, or only those that target an
        NSDB that supports encrypted communication. If an NSDB client
        chooses to follow an LDAP referral, the NSDB client MUST
        process the LDAP referral and prevent looping as described in
        Section 4.1.10 of <xref target="RFC4511"/>. </t>

    </section>

    </section>

    <section title="Security Considerations">

    <t> Both NFSv4/NFSv4.1 and LDAP provide security mechanisms. When used in
    conjunction with the federated filesystem protocols described in
    this document, the use of these mechanisms is RECOMMENDED. Specifically,
    the use of RPCSEC_GSS <xref target="RFC2203"/>, which is built on the
    GSS-API <xref target="RFC2743"/>, is RECOMMENDED on all NFS connections
    between a client and fileserver. The "Security Considerations" sections of
    the NFSv4 <xref target="3530bis"/> and NFSv4.1 <xref target="RFC5661"/>
    specifications contain special considerations for the handling of GETATTR
    operations for the fs_locations and fs_locations_info attributes. For all
    LDAP connections established by the federated filesystem protocols, the
    use of TLS <xref target="RFC5246"/>, as described in <xref target="RFC4513"/>,
    is RECOMMENDED. </t>

    <t> If an NSDB client chooses to follow an LDAP referral, the NSDB
    client SHOULD authenticate the LDAP referral's target NSDB using the
    target NSDB's credentials (not the credentials of the NSDB that
    generated the LDAP referral). The NSDB client SHOULD NOT follow an
    LDAP referral that targets an NSDB for which it does not know the
    NSDB's credentials. </t>

    <t> Within a federation, there are two types of components an attacker
    may compromise: a fileserver and an NSDB. </t>

    <t> If an attacker compromises a fileserver, the attacker can interfere
    with the client's filesystem I/O operations (e.g., by returning fictitious
    data in the response to a read request) or fabricating a referral. The
    attacker's abilities are the same regardless of whether or not the
    federation protocols are in use. While the federation protocols do not
    give the attacker additional capabilities, they are additional targets for
    attack. The LDAP protocol described in <xref target="nsdb-ops-fileservers"/>
    SHOULD be secured using the methods described above to defeat attacks
    on a fileserver via this channel. </t>

    <t> If an attacker compromises an NSDB, the attacker will be able to
    forge FSL information and thus poison the fileserver's referral
    information. Therefore an NSDB should be as secure as the fileservers
    which query it. The LDAP operations described in <xref target="nsdb-ops"/>
    SHOULD be secured using the methods described above to defeat attacks
    on an NSDB via this channel. </t>

    <t> A fileserver binds anonymously when performing NSDB operations.
    Thus the contents and distinguished names of FSN and FSL records are
    required to be readable by anyone who can bind anonymously to an NSDB
    service. <xref target="sec:uuid" /> presents the security considerations
  in the choice of the type of UUID used in these records. </t>

    <t> It should be noted that the federation protocols do not directly
    provide access to filesystem data. The federation protocols only
    provide a mechanism for building a namespace. All data transfers
    occur between a client and server just as they would if the federation
    protocols were not in use. As a result, the federation protocols do not
    require new user authentication and authorization mechanisms or require
    a fileserver to act as a proxy for a client. </t>

    </section>

    <section title="IANA Considerations">

        <section title="Registry for the fedfsAnnotation Key Namespace">

    <t> This document defines the fedfsAnnotation key in <xref target="fedfsAnnotation"/>.
    The fedfsAnnotation key namespace is to be managed by IANA. IANA is to create
    and maintain a new registry entitled "FedFS Annotation Keys". Future registrations
    are to be administered by IANA using the "First Come First Served" policy defined in
    <xref target="RFC5226"/>. Registration requests MUST include the key (a
    valid UTF-8 string of any length), a brief description of the key's purpose, and an
    email contact for the registration. For viewing, the registry should be sorted
    lexicographically by key. There are no initial assignments for this registry. </t>

        </section>

        <section title="Registry for FedFS Object Identifiers">

    <t> Using the process described in <xref target="RFC2578"/>, one of
    the authors was assigned the Internet Private Enterprise
    Numbers range 1.3.6.1.4.1.31103.x. Within this range, the subrange
    1.3.6.1.4.1.31103.1.x is permanently dedicated for use by the federated
    file system protocols. </t>

    <t> IANA is to create and maintain a new registry entitled "FedFS Object Identifiers"
    for the purpose of administering the FedFS Object Identifier (OID) range. Future
    allocations from the 1.3.6.1.4.1.31103.1.x range are to be assigned by IANA using
    the "RFC Required" policy defined in <xref target="RFC5226"/>. Registration requests
    MUST include an OID value from the 1.3.6.1.4.1.31103.1.x range, a short description of
    the OID, and a reference to the specification that defines the OID's usage. For viewing,
    the registry should be sorted numerically by OID value. The initial contents of the
    FedFS Object Identifiers registry are given in <xref target="oid_registry"/>. </t>

    <t><cref>
    RFC Editor: please replace RFC-TBD1 with this specification's RFC number.
    </cref></t>

      <texttable anchor="oid_registry">
        <ttcol align='left' >OID</ttcol>
        <ttcol align='left' >Description</ttcol>
        <ttcol align='left' >Reference</ttcol>

        <c> 1.3.6.1.4.1.31103.1.2    </c> <c> fedfsNetAddr            </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.3    </c> <c> fedfsNetPort            </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.4    </c> <c> fedfsFsnUuid            </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.7    </c> <c> fedfsNceDN              </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.8    </c> <c> fedfsFslUuid            </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.9    </c> <c> fedfsFslHost            </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.10   </c> <c> fedfsFslPort            </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.11   </c> <c> fedfsFslTTL             </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.12   </c> <c> fedfsAnnotation         </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.13   </c> <c> fedfsDescr              </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.100  </c> <c> fedfsNfsPath            </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.103  </c> <c> fedfsNfsCurrency        </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.104  </c> <c> fedfsNfsGenFlagWritable </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.105  </c> <c> fedfsNfsGenFlagGoing    </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.106  </c> <c> fedfsNfsGenFlagSplit    </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.107  </c> <c> fedfsNfsTransFlagRdma   </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.108  </c> <c> fedfsNfsClassSimul      </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.109  </c> <c> fedfsNfsClassHandle     </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.110  </c> <c> fedfsNfsClassFileid     </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.111  </c> <c> fedfsNfsClassWritever   </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.112  </c> <c> fedfsNfsClassChange     </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.113  </c> <c> fedfsNfsClassReaddir    </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.114  </c> <c> fedfsNfsReadRank        </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.115  </c> <c> fedfsNfsReadOrder       </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.116  </c> <c> fedfsNfsWriteRank       </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.117  </c> <c> fedfsNfsWriteOrder      </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.118  </c> <c> fedfsNfsVarSub          </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.119  </c> <c> fedfsNfsValidFor        </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.1001 </c> <c> fedfsNsdbContainerInfo  </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.1002 </c> <c> fedfsFsn                </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.1003 </c> <c> fedfsFsl                </c> <c> RFC-TBD1 </c>
        <c> 1.3.6.1.4.1.31103.1.1004 </c> <c> fedfsNfsFsl             </c> <c> RFC-TBD1 </c>
      </texttable>

        </section>

        <section title="LDAP Descriptor Registration">

    <t> In accordance with Section 3.4 and Section 4 of <xref target="RFC4520"/>,
    the object identifier descriptors defined in this document (listed below) will
    be registered via the Expert Review process. </t>

<?rfc subcompact="yes" ?>
    <t>
        <list style="hanging">
        <t hangText="Subject:"> Request for LDAP Descriptor Registration </t>
        <t hangText="Person &amp; email address to contact for further information:">
            See "Author/Change Controller" </t>
        <t hangText="Specification:"> draft-ietf-nfsv4-federated-fs-protocol </t>
        <t hangText="Author/Change Controller:"> [document authors] </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.2 </t>
        <t hangText="Descriptor (short name):"> fedfsNetAddr </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.3 </t>
        <t hangText="Descriptor (short name):"> fedfsNetPort </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.4 </t>
        <t hangText="Descriptor (short name):"> fedfsFsnUuid </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.7 </t>
        <t hangText="Descriptor (short name):"> fedfsNceDN </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.8 </t>
        <t hangText="Descriptor (short name):"> fedfsFslUuid </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.9 </t>
        <t hangText="Descriptor (short name):"> fedfsFslHost </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.10 </t>
        <t hangText="Descriptor (short name):"> fedfsFslPort </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.11 </t>
        <t hangText="Descriptor (short name):"> fedfsFslTTL </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.12 </t>
        <t hangText="Descriptor (short name):"> fedfsAnnotation </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.13 </t>
        <t hangText="Descriptor (short name):"> fedfsDescr </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.100 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsPath </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.103 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsCurrency </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.104 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsGenFlagWritable </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.105  </t>
        <t hangText="Descriptor (short name):"> fedfsNfsGenFlagGoing </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.106 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsGenFlagSplit </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.107 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsTransFlagRdma </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.108 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassSimul </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.109 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassHandle </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.110 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassFileid </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.111 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassWritever </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.112 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassChange </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.113 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsClassReaddir </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.114 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsReadRank </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.115 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsReadOrder </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.116 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsWriteRank </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.117 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsWriteOrder </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.118 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsVarSub </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.119 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsValidFor </t>
        <t hangText="Usage:"> attribute type </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1001 </t>
        <t hangText="Descriptor (short name):"> fedfsNsdbContainerInfo </t>
        <t hangText="Usage:"> object class </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1002 </t>
        <t hangText="Descriptor (short name):"> fedfsFsn </t>
        <t hangText="Usage:"> object class </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1003 </t>
        <t hangText="Descriptor (short name):"> fedfsFsl </t>
        <t hangText="Usage:"> object class </t>
        </list>
    </t>

    <t>
        <list style="hanging">
        <t hangText="Object Identifier:"> 1.3.6.1.4.1.31103.1.1004 </t>
        <t hangText="Descriptor (short name):"> fedfsNfsFsl </t>
        <t hangText="Usage:"> object class </t>
        </list>
    </t>
<?rfc subcompact="no" ?>

        </section>

    </section>

    <section title="Glossary">
        <?rfc include="glossary.xml"?>
    </section>

</middle>

<back>

    <references title='Normative References'>

        <?rfc include="references/reference.RFC.2119.xml"?>
        <?rfc include="references/reference.RFC.2203.xml"?>
        <?rfc include="references/reference.RFC.2578.xml"?>
        <?rfc include="references/reference.RFC.2743.xml"?>
        <?rfc include="references/reference.RFC.2849.xml"?>
        <?rfc include="references/reference.RFC.3986.xml"?>
        <?rfc include="references/reference.RFC.4291.xml"?>
        <?rfc include="references/reference.RFC.4122.xml"?>
        <?rfc include="references/reference.RFC.4510.xml"?>
        <?rfc include="references/reference.RFC.4511.xml"?>
        <?rfc include="references/reference.RFC.4512.xml"?>
        <?rfc include="references/reference.RFC.4513.xml"?>
        <?rfc include="references/reference.RFC.4516.xml"?>
        <?rfc include="references/reference.RFC.4517.xml"?>
        <?rfc include="references/reference.RFC.4519.xml"?>
        <?rfc include="references/reference.RFC.4520.xml"?>
        <?rfc include="references/reference.RFC.4530.xml"?>
        <?rfc include="references/reference.RFC.5226.xml"?>
        <?rfc include="references/reference.RFC.5234.xml"?>
        <?rfc include="references/reference.RFC.5246.xml"?>
        <?rfc include="references/reference.RFC.5661.xml"?>
        <?rfc include="references/reference.I-D.ietf-nfsv4-rfc3530bis.xml"?>

    </references>

    <references title='Informative References'>

        <?rfc include="references/reference.RFC.1094.xml"?>
        <?rfc include="references/reference.RFC.1813.xml"?>
        <?rfc include="references/reference.RFC.3254.xml"?>
        <?rfc include="references/reference.AFS.xml"?>
        <?rfc include="references/reference.RFC.5716.xml"?>
        <?rfc include="references/reference.I-D.ietf-nfsv4-federated-fs-admin.xml"?>
        <?rfc include="references/reference.I-D.ietf-nfsv4-federated-fs-dns-srv-namespace.xml"?>
        <?rfc include="references/reference.RFC.5662.xml"?>
        <?rfc include="references/reference.MS-SMB.xml"?>
        <?rfc include="references/reference.MS-SMB2.xml"?>
        <?rfc include="references/reference.MS-CIFS.xml"?>

    </references>

    <section anchor="app-additional" title="Acknowledgments">
        <t> We would like to thank Andy Adamson of NetApp, Paul Lemahieu of EMC,
            Robert Thurlow of Sun Microsystems, and Mario Wurzl of EMC for helping
            to author this document. </t>

        <t> We would also like to thank George Amvrosiadis, Chuck Lever,
            Trond Myklebust, and Nicolas Williams for their comments. </t>

        <t> The extract.sh shell script and formatting conventions were
            first described by the authors of the NFSv4.1 XDR specification
            <xref target="RFC5662"/>. </t>

    </section>

</back>
</rfc>
