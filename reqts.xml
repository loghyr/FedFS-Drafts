<?xml version="1.0" encoding="UTF-8"?>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc toc="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc strict="yes" ?>

<rfc category="info" docName="draft-ietf-nfsv4-federated-fs-reqts-06" ipr="pre5378Trust200902">

<front>
        <title>Requirements for Federated File Systems</title>

	<?rfc include="author-lentini-james.xml"?>
	<?rfc include="author-everhart-craig.xml"?>
	<?rfc include="author-ellard-daniel.xml"?>
	<?rfc include="author-tewari-renu.xml"?>
	<?rfc include="author-naik-manoj.xml"?>

        <date/>

	<area> Internet </area> 
	<workgroup>NFSv4 Working Group</workgroup>
	<keyword> Federated File Systems </keyword>

        <abstract>
	
	    <t> This document describes and lists the functional
		requirements of a federated file system and defines
		related terms.</t>

	</abstract>

	<note title="Requirements Language">

	    <t> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
		"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",
		"MAY", and "OPTIONAL" in this document are to be
		interpreted as described in <xref target="RFC2119"/>. 
		</t>

	    <t> Note, that this is a requirements document, and in many
		instances where these words are used in this document they
		refer to qualities of a specification for a system that
		satisfies the document, or requirements of a system that
		matches that specification.  These cases are distinguished
		when there is potential for ambiguity.  </t>

	</note>

</front>

<middle>

<section title="Overview">

    <t> This document describes and lists the functional requirements of
	a federated file system and defines related terms. </t>

    <t> We do not describe the mechanisms that might be used to
	implement this functionality except in cases where specific
	mechanisms, in our opinion, follow inevitably from the
	requirements.  Our focus is on the interfaces between the
	entities of the system, not on the protocols or their
	implementations.  </t>

    <t> Today, there are collections of fileservers that inter-operate
	to provide a single namespace comprised of filesystem
	resources provided by different members of the collection,
	joined together with inter-filesystem references.  The
	namespace can either be assembled at the fileservers, the
	clients, or by an external namespace service, and is often
	not easy or uniform to manage.  The requirements in this
	draft are meant to lead to a uniform server-based namespace
	that is capable of spanning a whole enterprise and which is
	easy to manage. </t>

    <t> We define some terms to better describe the solution space.  A
	"fileset" is the abstract view of a filesystem in a uniform
	namespace, and may be implemented behind that abstraction by one or
	more physical filesystems at any given time.  Each fileset has a
	name called an "FSN" (fileset name), and each physical filesystem
	has a fileset location ("FSL").  A fileset is a directory tree
	containing files and directories, and it may also contain references 
	to other filesets.  These references are called "junctions".  To
	provide location independence, a junction does not contain information
	about the location of the real resource(s), but instead contains an
	FSN that can be used to look up the location information.  The
	service that can be used to map from FSN to FSL(s) is called a
	namespace database (NSDB) service.  The NSDB provides a level of
	indirection from the virtual paths in the uniform namespace to the
	actual locations of files. By design, the NSDB does not store the 
	junctions. This allows junction administration and NSDB administration 
	to be separate roles. </t>

    <t> The servers direct clients to the proper locations by existing
	mechanisms (e.g. the referrals mechanism within <xref target="RFC3530"/>
	and <xref target='NFSv4.1'/>). Updates to the locations make it possible
	to support migration and replication of physical filesystems that
	comprise the namespace, in a way that is transparent to filesystem
	applications. </t>

    <t> <xref target="federation-pic"/> shows an example
	of a federation.  This federation has two members, named
	ALPHA and BETA.  Federation members may contain an arbitrary
	number of file servers and NSDB nodes; in this illustration
	ALPHA and BETA each have three servers and one NSDB node. </t>

    <figure anchor="federation-pic">
            <?rfc include="fig-federation.aa"?>
	<postamble>
	
	    A federation with two members, ALPHA and BETA.  ALPHA and
	    BETA each have their own NSDB node and several file
	    servers, and they are administered separately.

	</postamble>
    </figure>

</section>

<section title="Purpose">

    <t> Our objective is to specify a set of protocols by which
	fileservers or collections of fileservers, with different 
	administrators, can form a federation of fileservers and
	NSDB nodes that provides a namespace composed of the filesets
	hosted on the different fileservers and fileserver collections.  </t>

    <t> It should be possible, using a system that implements the
	protocols, to share a common namespace across all the
	fileservers in the federation.  It should also be possible for
	different fileservers in the federation to project different
	namespaces and enable clients to traverse them.  </t>

    <t> Such a federation may contain an arbitrary number of NSDB nodes,
	each belonging to a different administrative entity, and each
	providing the mappings that define a part of a namespace. 
	Such a federation may also have an arbitrary number of
	administrative entities, each responsible for administering a
	subset of the fileservers and NSDB nodes.  Acting in concert, the
	administrators should be able to build and administer this
	multi-fileserver, multi-collection namespace.  </t>

    <t> It is not the intent of the federation to guarantee namespace
	consistency across all client views.  Since different parts of
	the namespace may be administered by different entities, it is
	possible that a client could be accessing a stale area of the
	namespace managed by one entity because a part of the
	namespace above it, managed by another entity, has changed. 
	</t>

</section>

<section title="Examples and Discussion">

    <t> In this section we provide examples and discussion of the
	basic operations facilitated by the federated file system
	protocol:  creating a fileset, adding a replica of a fileset,
	resolving a junction, and creating a junction.  </t>

    <section title="Create a Fileset and its FSL(s)">

	<t> A fileset is the abstraction of a set of files and their
	    containing directory tree.  The fileset abstraction is the
	    fundamental unit of data management in the federation. 
	    This abstraction is implemented by an actual directory
	    tree whose root location is specified by a fileset
	    location (FSL).  </t>

	<t> In this section, we describe the basic requirements for
	    starting with a directory tree and creating a fileset that
	    can be used in the federation protocols.  Note that we do
	    not assume that the process of creating a fileset requires
	    any transformation of the files or the directory
	    hierarchy.  The only thing that is required by this
	    process is assigning the fileset a fileset name (FSN) and
	    expressing the location(s) of the implementation of the
	    fileset as FSL(s).  </t>

	<t> There are many possible variations to this procedure,
	    depending on how the FSN that binds the FSL is created,
	    and whether other replicas of the fileset exist, are known
	    to the federation, and need to be bound to the same FSN. 
	    </t>

	<t> It is easiest to describe this in terms of how to create
	    the initial implementation of the fileset, and then
	    describe how to add replicas.  </t>

	<section title="Creating a Fileset and an FSN">

	    <t>
		<list style="numbers">

		    <t> Choose the NSDB node that will keep track of the
			FSL(s) and related information for the
			fileset.  </t>

		    <t> Request that the NSDB node register a new FSN for
			the fileset.

			<vspace blankLines="1" />

			The FSN may either be chosen by the NSDB node
			or by the server.  The latter case is used if
			the fileset is being restored, perhaps as part
			of disaster recovery, and the server wishes to
			specify the FSN in order to permit existing
			junctions that reference that FSN to work
			again.

			<vspace blankLines="1" />

			At this point, the FSN exists, but its
			location is unspecified.

		    </t>

		    <t> Send the FSN, the local volume path, the
			export path, and the export options for the
			local implementation of the fileset to the
			NSDB node.  Annotations about the FSN or the
			location may also be sent.

			<vspace blankLines="1" />

			The NSDB node records this info and creates the
			initial FSL for the fileset.

		    </t>
		</list>
	    </t>
	</section>

	<section title="Adding a Replica of a Fileset">

	    <t> Adding a replica is straightforward:  the NSDB node
		and the FSN are already known.  The only remaining
		step is to add another FSL.  </t>

	    <t> Note that the federation protocols do not include
		methods for creating or managing replicas:  this is
		assumed to be a platform-dependent operation (at least
		at this time).  The only requirement is that these 
		fileset replicas be registered and unregistered with
		the NSDB.  </t>

	</section>

    </section>

    <section title="Junction Resolution">

	<t> A fileset may contain references to other filesets.  These
	    references are represented by junctions.  If a client
	    requests access to a fileset object that is a junction,
	    the server resolves the junction to discover the FSL(s)
	    that implements the referenced fileset. </t>

	<t> There are many possible variations to this procedure,
	    depending on how the junctions are represented and how
	    the information necessary to perform resolution is
	    represented by the server.  </t>

	<t> Step 4 is the only step that interacts directly with
	    the federation protocols.  The rest of the steps may
	    use platform-specific interfaces.  </t>

	<t>
	    <list style="numbers">

		<t> The server determines that the object being
		    accessed is a junction.  </t>

		<t> Using the junction, the server does a local
		    lookup to find the FSN of the target fileset. 
		    </t>

		<t> Using the FSN, the server finds the NSDB node
		    responsible for the target object.  </t>

		<t> The server contacts that NSDB node and asks for
		    the set of FSLs that implement the target FSN. 
		    The NSDB node responds with a set of FSLs.  </t>

		<t> The server converts one or more of the FSLs to 
		    the location type used by the client (e.g., 
		    a Network File System (NFSv4) fs_location,
		    as described in <xref target="RFC3530"/>).</t>

		<t> The server redirects (in whatever manner is
		    appropriate for the client) the client to the
		    location(s).  </t>

	    </list>

	</t>

	<t> These steps are illustrated in <xref
	    target='resolution'/>.  The client sends request 1 to
	    server X, in federation member ALPHA, in an attempt to
	    reference an object (which appears to the client as a directory).
	    Server X
	    recognizes that the referenced object is actually a junction
	    that refers to a directory in a different fileset.
	    Server X finds, from the FSN
	    in the junction, that the NSDB responsible for knowing the
	    location of the target of the junction is the NSDB of
	    federation member BETA.  Server X sends request 2 to the
	    NSDB of BETA, asking for the current location of the
	    directory.  The NSDB sends response 3 to server X, telling
	    the server that the directory is located on server Y. 
	    Server X sends response 4 to the client, indicating that
	    the directory is in a "new" location on server Y.  The
	    client then sends request 5 to server Y, repeating the
	    initial request.  </t>

	<t> Given the current requirements and definitions, this
	    resolution method MUST work.  However, there is no
	    requirement that this is the only resolution method that
	    can be used.  This method may be used as the fallback when
	    all else fails (or, for a simple implementation, it could
	    be the only method).  This is a degenerate implementation
	    of the NSDB service as a simple composition of NSDB nodes;
	    we expect that large federations will use more
	    sophisticated methods to share the FSN and FSL information
	    among multiple NSDB nodes.  </t>

	    <figure anchor="resolution">
		    <?rfc include="fig-resolution.aa"?>
	    </figure>

    </section>

    <section title="Junction Creation">

	<t> Given a local path and the FSN of a remote fileset, an 
	    administrator can create a junction from the local path to the
	    remote fileset.  </t>

	<t> There are many possible variations to this procedure,
	    depending on how the junctions are represented and how the
	    information necessary to perform resolution is represented
	    by the server.  </t>

	<t> Step 1 is the only step that uses the federation
	    interfaces.  The remaining step may use
	    platform-specific interfaces.  </t>

	<t>
	    <list style="numbers">

		<t> The administrator requests the server create a 
		    junction to the FSN of the remote fileset at the 
		    given path.  </t>

		<t> The server inserts the junction to the FSN, at the given
		    path, into the local filesystem.  </t>

	    </list>
	</t>

    </section>
</section>

<section title="Glossary">

    <?rfc include="glossary.xml"?>

</section>

<section title="Proposed Requirements">

    <t> The phrase "USING THE FEDERATION INTERFACES" implies that the
	subsequent requirement must be satisfied, in its entirety, via
	the federation interfaces.  </t>

    <t> Note that the requirements are described in terms of correct
	behavior by all entities.  We do not address the requirements
	of the system in the presence of faults.  </t>

    <section title="Basic Assumptions">

	<t> Several of the requirements are so fundamental that we
	    treat them as basic assumptions; if any of these
	    assumptions are violated, the rest of the requirements
	    must be reviewed in their entirety.  </t>

	<t>
	    <list style="format A%d:">

		<t> The federation protocols do not require any
		    changes to existing client-facing protocols, and
		    MAY be extended to incorporate new client-facing
		    protocols.  </t>

		<t> A client SHOULD NOT require any a priori knowledge
		    of the general structure or composition of the
		    federation.

		    <vspace blankLines="1" />

		    The client may require some specific knowledge in
		    order to find and access an instance of the
		    fileset that defines the root of its view of the
		    namespace.  As the client traverses the namespace,
		    the client discovers the information it needs in
		    order to locate the filesets it accesses.

		</t>

		<t> All requirements MUST be satisfiable via the
		    federation protocols and the standard protocols
		    used by the fileservers (i.e., NFS, CIFS, DNS,
		    etc).

		    <vspace blankLines="1" />

		    USING THE FEDERATION INTERFACES, a federation
		    operation that requires an interaction between two
		    (or more) entities that are members of the
		    federation MUST be possible without requiring any
		    proprietary protocols.

		</t>

		<t> All the entities participating in a federation
		    operation MUST be able to authenticate each
		    other.

		    <vspace blankLines="1" />

		    All principals (clients, users, administrator of a
		    singleton or server collection, hosts, NSDB nodes,
		    etc) that can assume a role defined by the
		    federation protocol can identify themselves to
		    each other via an authentication mechanism.  This
		    mechanism is not defined or further described in
		    this document. 

		    <vspace blankLines="1" />

		    The authority of a principal to request that a
		    second principal perform a specific operation is
		    ultimately determined by the second. 
		    Authorization may be partitioned by server
		    collection or set of servers as well as by
		    operation.  For example, if a user has
		    administrative privileges on one server in the
		    federation, this does not imply that they have
		    administrative privileges (or, for that matter,
		    any privileges whatsoever) on any other server in
		    the federation.

		    <vspace blankLines="1" />

		    In order to access the functionality provided by
		    the federation interfaces, it may be necessary to
		    have elevated privileges or authorization.  The
		    authority required by different operations may be
		    different.  For example, the authority required to
		    query the NSDB about the FSLs bound to an FSN may
		    be different than the authority required to change
		    the bindings of that FSN.

		    <vspace blankLines="1" />

		    An operation attempted by an unauthorized entity
		    MUST fail in a manner that indicates that the
		    failure was due to insufficient authorization.

		    <vspace blankLines="1" />

		    This document does not enumerate the authorization
		    necessary for any operation.

		</t>

		<t> The federation protocols MUST NOT require changes
		    to existing authentication/authorization
		    mechanisms in use at the fileservers for
		    client-facing protocols.

		    <vspace blankLines="1" />

		    A user's view of the namespace may be limited by
		    the authentication and authorization privileges it
		    has on the different fileservers in the
		    federation.  As such, users may only be able to
		    traverse the parts of the namespace that they have
		    access to.

		    <vspace blankLines="1" />

		    The federation protocols do not impose any
		    restrictions on how users are represented within
		    the federation.  For example, a single enterprise
		    could employ a common identity for users across
		    the federation.  A grid environment could utilize
		    user mapping or translations across different
		    administrative domains.

		</t>

		<t> In a federated system, we assume that an FSN MUST
		    express, or can be used to discover, the following
		    two pieces of information:

		    <list style="numbers">

			<t> The location of the NSDB node that is
			    responsible for knowing the filesystem
			    location(s) (FSLs) of the named fileset.

			    <vspace blankLines="1" />

			    The NSDB node must be specified because
			    there may be many NSDB nodes in a
			    federation.  We do not assume that any
			    single entity knows the location of all of
			    the NSDB nodes, and therefore exhaustive
			    search is not an option.

			    <vspace blankLines="1" />

			    There are several ways in which a
			    fileserver can locate the NSDB node
			    responsible for a given fileset.  One
			    approach, given a DNS infrastructure, is
			    to specify the location of the NSDB node
			    by the FQDN of the server hosting the NSDB
			    node.  Another approach is to use a
			    separate DNS-style hierarchy to resolve
			    the location of the NSDB node.

			</t>

			<t> The FSN identifier.

			    <vspace blankLines="1" />

			    The FSN identifier is the index used by the NSDB node to
			    identify the target fileset.

			    <vspace blankLines="1" />

			    There are several ways to represent FSN identifiers.  One 
			    approach could use 128-bit UUIDs as described described in
			    <xref target="RFC4122"/>.

			</t>

		    </list>

		    As an example, an FSN could be represented by a
		    URL of the form nsdb://nsdb.example.com/UUID where
		    nsdb is the scheme name, nsdb.example.com is the 
		    FQDN of the server hosting the NSDB node, and UUID is 
		    the string representation of the identifier.

		    <vspace blankLines="1" />

		    Note that it is not assumed that it is always
		    required for a server to contact the NSDB node
		    specified by the FSN in order to find the FSLs. 
		    The relevant information stored in that NSDB node
		    may also be cached local to the server or on a
		    proxy NSDB node "near" the server.

		</t>

		<t> All federation servers and NSDB nodes are assumed to
		    execute the federation protocols correctly.  The
		    behavior of the federation is undefined in the
		    case of Byzantine behavior by any federation
		    server or NSDB node.  </t>

		<t> The locations of federation services (such as
		    NSDBs and FSLs) can be specified in a manner such
		    that they can be correctly interpreted by all
		    members of the federation that will access them.

		    <vspace blankLines="1" />

		    For example, if an NSDB node is specified by a FQDN,
		    then this implies that every member of the
		    federation that needs to access this NSDB node can
		    resolve this FQDN to an IP address for that NSDB node. 
		    (It is not necessary that the FQDN always resolve
		    to the same address; the same service may appear
		    at different addresses on different networks.)

		    <vspace blankLines="1" />

		    It is the responsibility of each federation member
		    to ensure that the resources it wishes to expose
		    have accessible network locations and that the
		    necessary resolution mechanisms (i.e., DNS) are
		    given the necessary data to perform the resolution
		    correctly.

		</t>
	    </list>
	</t>
    </section>

    <section title="Requirements">

	<t>
	    <list style="format R%d:">

		<t> Requirements of each FSN:

		    <list style="format %c.">

         		<t> Each FSN MUST be unique within the scope
			    of its NSDB (so that the FSN is globally
			    unique). </t>

			<t> The FSN MUST be sufficiently descriptive
			    to locate an instance of the fileset it
			    names within the federation at any time. </t>

			<t> All FSNs MUST be invariant when their
			    underlying filesystems move or are replicated;
			    only mappings from FSN to FSL(s) change under
			    these transformations. </t>

			<t> All files accessible from the global namespace
			    MUST be part of a fileset that has an assigned
			    FSN. </t>

		    </list>

		    Not all filesets in the federation are required to
		    have an FSN or be reachable by an FSL.  Only those
		    filesets that are the target of a junction (as
		    described in R3) are required to have an FSN.

		    <vspace blankLines="1" />

		    The FSN format MAY be variable size. If the format is 
		    variable size, fileserver implementations MAY have a 
		    maximum supported FSN size. By bounding the FSN size, 
		    some fileserver implementations might be able to 
		    efficiently organize FSNs in stable storage. For 
		    interoperability, the federation protocols SHOULD define
		    an FSN size that all fileservers support.	
		</t>

		<t> USING THE FEDERATION INTERFACES, it MUST be
		    possible to create an FSN for a fileset, and
		    it must be possible to bind an FSL to that FSN.
		    These operations are NSDB operations and do
		    not require any action on the part of a file
		    server.

		    <vspace blankLines="1" />

		    It is possible to create an FSN for a fileset that
		    has not actually been created.  It is also
		    possible to bind a nonexistent FSL to an FSN.  It
		    is also possible to create a fileset without
		    assigning it an FSN.  The binding between an FSN
		    and an FSL is defined entirely within the context
		    of the NSDB; the servers do not "know" whether the
		    filesets they host have been assigned FSNs (or, if
		    so, what those FSNs are).

		    <vspace blankLines="1" />

		    The requirement that filesets can exist prior to being
		    assigned an FSN, and the requirement that FSNs can exist
		    independent of filesets are intended to simplify
		    the construction of the namespace in a convenient
		    manner.  For example, they permit an admin to
		    assign FSNs to existing filesets and thereby incorporate
		    existing filesets into the namespace.  They also
		    permit the structure of the namespace to be defined
		    prior to creation of the component filesets.
		    In either case, 
		    it is the responsibility of the entity
		    updating the NSDB with FSNs and FSN-to-FSL mappings
		    to ensure that the namespace is constructed in
		    a consistent manner.  (The simplest way to accomplish
		    this is to ensure that the FSN and FSN-to-FSL mappings
		    are always recorded in the NSDB prior to the creation
		    of any junctions that refer to that FSN.)

		    <list style="format %c.">

			<t> An administrator MAY specify the entire
			    FSN (including both the NSDB node location
			    and the identifier) of the newly-created
			    FSL, or the administrator MAY specify only
			    the NSDB node and have the system choose
			    the identifier.

			    <vspace blankLines="1" />

			    The admin can choose to specify the FSN
			    explicitly in order to recreate a lost
			    fileset with a given FSN (for example, as
			    part of disaster recovery).  It is an
			    error to assign an FSN that is already in
			    use by an active fileset.

			    <vspace blankLines="1" />

			    Note that creating a replica of an
			    existing filesystem is NOT accomplished by
			    assigning the FSN of the filesystem you
			    wish to replicate to a new filesystem.

			</t>

			<t> USING THE FEDERATION INTERFACES, it MUST
			    be possible to create a federation FSL by
			    specifying a specific local volume, path,
			    export path, and export options.  </t>

		    </list>
		</t>

		<t> USING THE FEDERATION INTERFACES, and given the FSN
		    of a target fileset, it MUST be possible to create
		    a junction to that fileset at a named place in
		    another fileset.

		    <vspace blankLines="1" />

		    After a junction has been created, clients that
		    access the junction transparently interpret it as
		    a reference to the FSL(s) that implement the FSN
		    associated with the junction.

		    <list style="format %c.">

			<t> It SHOULD be possible to have more than
			    one junction whose target is a given
			    fileset.  In other words, it SHOULD be
			    possible to mount a fileset at multiple
			    named places.  </t>

			<t> If the fileset in which the junction is
			    created is replicated, then the junction
			    MUST eventually appear in all of its
			    replicas.

			    <vspace blankLines="1" />

			    The operation of creating a junction
			    within a fileset is treated as an update
			    to the fileset, and therefore obey the
			    general rules about updates to replicated
			    filesets.

			</t>
		    </list>
		</t>

		<t> USING THE FEDERATION INTERFACES, it MUST be
		    possible to delete a specific junction from a
		    fileset.

		    <vspace blankLines="1" />

		    If a junction is deleted, clients who are already
		    viewing the fileset referred to by the junction
		    after traversing the junction MAY continue to view
		    the old namespace.  They might not discover that
		    the junction no longer exists (or has been deleted
		    and replaced with a new junction, possibly
		    referring to a different FSN).

		    <vspace blankLines="1" />

		    After a junction is deleted, another object with
		    the same name (another junction, or an ordinary
		    filesystem object) may be created.

		    <vspace blankLines="1" />

		    The operation of deleting a junction within a
		    fileset is treated as an update to the fileset,
		    and therefore obey the general rules about updates
		    to replicated filesets.

		</t>

		<t> USING THE FEDERATION INTERFACES, it MUST be
		    possible to invalidate an FSN.

		    <list style="format %c.">

			<t> If a junction refers to an FSN that is
			    invalid, attempting to traverse the
			    junction MUST fail.  </t>

		    </list>

		    An FSN that has been invalidated MAY become valid
		    again if the FSN is recreated (i.e., as part of a
		    disaster recovery process).

		    <vspace blankLines="1" />

		    If an FSN is invalidated, clients who are already
		    viewing the fileset named by the FSN MAY continue to
		    view the old namespace.  They might not discover that
		    the FSN is no longer valid until they try to traverse
		    a junction that refers to it.

		</t>

		<t> USING THE FEDERATION INTERFACES, it MUST be possible
		    to invalidate an FSL.

		    <list style="format %c.">

			<t> An invalid FSL MUST NOT be returned as the
			    result of resolving a junction.  </t>

		    </list>

		    An FSL that has been invalidated MAY become valid
		    again if the FSL is recreated (i.e., as part of a
		    disaster recovery process).

		    <vspace blankLines="1" />

		    If an FSL is invalidated, clients who are already
		    viewing the fileset implemented by the FSL MAY
		    continue to use that FSL.  They might not discover
		    that the FSL is no longer valid until they try to
		    traverse a junction that refers to the fileset
		    implemented by the FSL.

		    <vspace blankLines="1" />

		    Note that invalidating an FSL does not imply that the
		    underlying export or share (depending on the file
		    access protocol in use) is changed in any way
		    -- it only changes the mappings from FSNs to FSLs on
		    the NSDB.

		</t>

		<t> It MUST be possible for the federation of servers to
		    provide multiple namespaces.  </t>

		<t> USING THE FEDERATION INTERFACES:

		    <list style="format %c.">

			<t> It MUST be possible to query the fileserver
			    named in an FSL to discover whether a junction
			    exists at a given path within that FSL. </t>

			<t> It MAY be possible to query the fileserver named
			    in an FSL to discover the junctions, if any, in
			    that FSL. If this feature is implemented, the fileserver
			    SHOULD report each junction's path within the FSL and the
			    targeted FSN. </t>

		    </list>

		</t>

		<t anchor="supported-protocols"> The projected namespace (and the objects named by the
		    namespace) MUST be accessible to clients via at least
		    one of the following standard filesystem access protocols:

		    <list style="format %c.">

			<t> The namespace SHOULD be accessible to clients
			    via versions of the CIFS (SMB) protocol 
			    <xref target="MS-SMB"/> <xref target="MS-SMB2"/>
			    <xref target="MS-CIFS"/>.  </t>

			<t> The namespace SHOULD be accessible to clients
			    via the NFSv4 protocol
			    as described in <xref target="RFC3530"/>.  </t>

			<t> The namespace SHOULD be accessible to clients
			    via the NFSv3 protocol
			    as described in <xref target="RFC1813"/>.  </t>

			<t> The namespace SHOULD be accessible to clients
			    via the NFSv2 protocol
			    as described in <xref target="RFC1094"/>.  </t>

		    </list>

		    It must be understood that some of these
		    protocols, such as NFSv3 and NFSv2, have no innate
		    ability to access a namespace of this kind.  Where
		    such protocols have been augmented with other
		    protocols and mechanisms (such as autofs or amd
		    for NFSv3) to provide an extended namespace, we
		    propose that these protocols and mechanisms may be
		    used, or extended, in order to satisfy the
		    requirements given in this draft, and different
		    clients may use different mechanisms. 

		    <vspace blankLines="1" />

		</t>

		<t> USING THE FEDERATION INTERFACES, it MUST be possible
		    to modify the NSDB mapping from an FSN to a set of
		    FSLs to reflect the migration from one FSL to another. 
		    </t>

		<t> FSL migration SHOULD have little or no impact on the
		    clients, but this is not guaranteed across all
		    federation members.

		    <vspace blankLines="1" />

		    Whether FSL migration is performed transparently
		    depends on whether the source and destination servers
		    are able to do so.  It is the responsibility of the
		    administrator to recognize whether or not the
		    migration will be transparent, and advise the system
		    accordingly.  The federation, in turn, MUST advise the
		    servers to notify their clients, if necessary.

		    <vspace blankLines="1" />

		    For example, on some systems, it may be possible to
		    migrate a fileset from one system to another with
		    minimal client impact because all client-visible
		    metadata (inode numbers, etc) are preserved during
		    migration.  On other systems, migration might be quite
		    disruptive. 

		</t>

		<t> USING THE FEDERATION INTERFACES, it MUST be possible
		    to modify the NSDB mapping from an FSN to a set of
		    FSLs to reflect the addition/removal of a replica at a
		    given FSL.  </t>

		<t> Replication SHOULD have little or no negative impact
		    on the clients.

		    <vspace blankLines="1" />

		    Whether FSL replication is performed transparently
		    depends on whether the source and destination servers
		    are able to do so.  It is the responsibility of the
		    administrator initiating the replication to recognize
		    whether or not the replication will be transparent,
		    and advise the federation accordingly.  The federation
		    MUST advise the servers to notify their clients, if
		    necessary.

		    <vspace blankLines="1" />

		    For example, on some systems, it may be possible to
		    mount any FSL of an FSN read/write, while on other
		    systems, there may be any number of read-only replicas
		    but only one FSL that can be mounted read-write.

		</t>

		<t>  USING THE FEDERATION INTERFACES, it SHOULD be
		    possible to annotate the objects and relations managed
		    by the federation protocol with arbitrary name/value
		    pairs.

		    <vspace blankLines="1" />

		    These annotations are not used by the federation
		    protocols -- they are intended for use by higher-level
		    protocols.  For example, an annotation that might be
		    useful for a system administrator browsing the
		    federation would be the "owner" of each FSN (i.e.,
		    "this FSN is for the home directory of Joe Smith."). 
		    As another example, the annotations may express hints
		    used by the clients (such as priority information for
		    NFSv4.1).

		    <vspace blankLines="1" />

		    Both FSNs and FSLs may be annotated.  For example, an
		    FSN property might be "This is Joe Smith's home
		    directory", and an FSL property might be "This
		    instance of the FSN is at the remote backup site."

		    <vspace blankLines="1" />

		    <list style="format %c.">

			<t> USING THE FEDERATION INTERFACES, it MUST be
			    possible to query the system to find the
			    annotations for a junction.  </t>

			<t> USING THE FEDERATION INTERFACES, it MUST be
			    possible to query the system to find the
			    annotations for an FSN.  </t>

			<t> USING THE FEDERATION INTERFACES, it MUST be
			    possible to query the system to find the
			    annotations for an FSL.  </t>

		    </list>
		</t>


		<t>  It MUST be possible for the federation to project a
		     namespace with a common root.

		    <vspace blankLines="1" />

		    <list style="format %c.">

			<t> It SHOULD be possible to define a root fileset that is
			    exported by one or more fileservers in the federation
			    as the top level of a namespace. [Corollary: There is
			    one root fileset per namespace and it is possible to
			    support multiple namespaces per federation.] </t>

			<t> It SHOULD be possible for a fileserver to locate an
			    NSDB that stores the layout of a root fileset. </t>

			<t> It SHOULD be possible to access, store and update
			    information related to a root fileset using the
			    federation protocols. </t>

			<t> It SHOULD be possible to replicate root fileset
			    information across multiple repositories. </t>

			<t> If a root fileset is defined it SHOULD be possible
			    to enable a file server to export that root fileset
			    for client access. </t>

			<t> If a root fileset is defined it SHOULD be possible
			    for multiple file servers to project a common root
			    with defined consistency semantics. </t>

			<t> If a root fileset is defined it SHOULD be stored 
			    using a compact representation that is compatible 
			    with heterogeneous fileserver implementations. The 
			    root fileset's internal format SHOULD contain enough 
			    information to generate any attributes, including 
			    referrals, required by the standard filesystem access 
			    protocols in 
			    R<xref format="counter" target="supported-protocols"/>.</t>

		    </list>
		</t>

	    </list>
	</t>
    </section>
</section>

<section title="Non-Requirements">

    <t>
	<list style="format N%d:">

	    <t> It is not necessary for the namespace to be known by
		any specific fileserver.

		<vspace blankLines="1" />

		In the same manner that clients do not need to have a
		priori knowledge of the structure of the namespace or
		its mapping onto federation members, the projected
		namespace can exist without individual fileservers
		knowing the entire organizational structure, or,
		indeed, without knowing exactly where in the projected
		namespace the filesets they host exist.

		<vspace blankLines="1" />

		Fileservers do need to be able to handle referrals
		from other fileservers, but they do not need to know
		what path the client was accessing when the referral
		was generated.

	    </t>

	    <t> It is not necessary for updates and accesses to the
		NSDB data to occur in transaction or transaction-like 
		contexts.

		<vspace blankLines="1" />

		One possible requirement that is omitted from our
		current list is that updates and accesses to the data
		stored in the NSDB (or individual NSDB nodes) occur
		within a transaction context.  We were not able to
		agree whether the benefits of transactions are worth
		the complexity they add (both to the specification and
		its eventual implementation) but this topic is open
		for discussion.

		<vspace blankLines="1" />

		Below is the the draft of a proposed requirement that
		provides transactional semantics:

		<list style="empty">

		    <t> "There MUST be a way to ensure that sequences
			of operations, including observations of the
			namespace (including finding the locations
			corresponding to a set of FSNs) and changes to
			the namespace or related data stored in the
			system (including the creation, renaming, or
			deletion of junctions, and the creation,
			altering, or deletion of mappings between FSN
			and filesystem locations), can be performed in
			a manner that provides predictable semantics
			for the relationship between the observed
			values and the effect of the changes." </t>

		    <t> "It MUST be possible to protect sequences of
			operations by transactions with NSDB-wide or
			server-wide ACID semantics." </t>

		</list>
	    </t>
	</list>
    </t>
</section>

<section title="Security Considerations">

    <t> Assuming the Internet threat model, the federated resolution
	mechanism described in this document MUST be implemented in
	such a way to prevent loss of CONFIDENTIALITY, DATA INTEGRITY
	and PEER ENTITY AUTHENTICATION, as described in <xref
	target="RFC3552"/>. </t>

    <t> CONFIDENTIALITY may be violated if an unauthorized party
	is able to eavesdrop on the communication between authorized
	servers and NSDB nodes and thereby learn the locations or
	other information about FSNs that they would not be authorized
	to discover via direct queries.  DATA INTEGRITY may be compromised
	if a third party is able to undetectably alter the contents
	of the communication between servers and NSDB nodes.  PEER
	ENTITY AUTHENTICATION is defeated if one server can
	masquerade as another server without proper authority, or
	if an arbitrary host can masquerade as a NSDB node. </t>

    <t> Well-established techniques for providing authenticated channels
	may be used to defeat these attacks, and the protocol MUST
	support at least one of them. </t>
	
    <t> For example, if LDAP is used to implement the query mechanism
	<xref target="RFC4510"/>, then TLS may be used to provide both
	authentication and integrity <xref target="RFC5246"/> <xref
	target="RFC4513"/>.  If the query protocol is implemented on
	top of ONC/RPC, then RPCSEC_GSS may be used to fill the same
	role <xref target="RFC2203"/> <xref target="RFC2743"/>. </t>

    <t> A federation could contain multiple Public Key Infrastructure (PKI) 
	trust anchors <xref target="RFC5280"/>.  The federation protocols 
	SHOULD define a mechanism for managing a fileserver's NSDB trust 
	anchors <xref target="TA-MGMT-REQS"/>. A general purpose trust anchor 
	management protocol <xref target="TAMP"/> would be appropriate, though 
	it might be desirable for the federation protocols to facilitate trust 
	anchor management by, for example, using trust anchor interchange 
	formats <xref target="TA-FORMAT"/>. </t>

    <t> It is useful to note that the requirements described in this 
        document lead naturally to a system with distributed 
        authorization, which has scalability and manageability
        benefits. </t>

    <t> FSNs are likely to be long lived resources. Therefore, 
        the privilege to create FSNs SHOULD be carefully controlled. 
        To assist in determining if an FSN is referenced by a junction 
        somewhere in the federation, the NSDB records SHOULD include 
        non-authoritative informational annotations recording the 
        locations of any such junctions. These annotations are 
        non-authoritative because a junction might be created, deleted, 
        or modified by an individual that does not have permission to 
        modify the NSDB records. </t>

</section>

<section title="IANA Considerations">

    <t> This document has no actions for IANA. </t>

</section>

</middle>

<back>
	<references title='Normative References'>

		<?rfc include="references/reference.RFC.2119.xml"?>
		<?rfc include="references/reference.RFC.3530.xml"?>
		<?rfc include="references/reference.RFC.3552.xml"?>
		<?rfc include="references/reference.RFC.4122.xml"?>
		<?rfc include="references/reference.RFC.4510.xml"?>
		<?rfc include="references/reference.RFC.5280.xml"?>
		<?rfc include="references/reference.I-D.ietf-nfsv4-minorversion1.xml"?>

	</references>

	<references title='Informational References'>

		<?rfc include="references/reference.RFC.1094.xml"?>
		<?rfc include="references/reference.RFC.1813.xml"?>
		<?rfc include="references/reference.RFC.2203.xml"?>
		<?rfc include="references/reference.RFC.2743.xml"?>
		<?rfc include="references/reference.RFC.4513.xml"?>
		<?rfc include="references/reference.RFC.5246.xml"?>
		<?rfc include="references/reference.I-D.ietf-pkix-ta-mgmt-reqs.xml"?>
		<?rfc include="references/reference.I-D.ietf-pkix-tamp.xml"?>
		<?rfc include="references/reference.I-D.ietf-pkix-ta-format.xml"?>
		<?rfc include="references/reference.MS-SMB.xml"?>
		<?rfc include="references/reference.MS-SMB2.xml"?>
		<?rfc include="references/reference.MS-CIFS.xml"?>

	</references>

	<section anchor="app-additional" title="Acknowledgments">
		<t> We would like to thank Robert Thurlow of Sun 
		    Microsystems for helping to author this document. </t>

		<t> We would also like to thank Peter McCann and
		    and Nicolas Williams for their comments and suggestions. </t>
	</section>
</back>

</rfc>
